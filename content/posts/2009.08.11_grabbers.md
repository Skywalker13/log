---
title: 'Le support des "grabbers" dans la Valhalla ~ üá´üá∑'
date: 2009-08-11
tags: [geexbox, libvalhalla]
description: "Grab, grab, grab, ..."
draft: false
---

> Les feuilles d'Yggdrasil ne sont plus si inaccessibles pour les braves de la
> Valhalla. Les "grabbers" auraient pu s'appeler [Heidrun][1] mais on se
> contentera d'un nom plus technique.

Les "grabbers" sont donc enfin support√©s dans libvalhalla. Il y a encore du
travail avant de pouvoir les utiliser correctement depuis Enna, mais l'essentiel
est l√†. Pour ceux qui n'ont aucune id√©e de ce qui se cache derri√®re ce mot
barbare "grabber", on pourrait le d√©finir simplement comme √©tant une mani√®re de
s'accaparer (si on traduit directement du mot anglais) ou alors de r√©cup√©rer des
donn√©es depuis des moyens ext√©rieurs. Par exemple, libvalhalla peut r√©cup√©rer
des m√©ta-donn√©es provenant directement des fichiers scann√©s, √† l'aide d'FFmpeg
(le parser). Mais si on d√©sire retrouver la couverture CD/DVD il n'√©tait pas
possible de le faire jusqu'ici. C'est l√† qu'intervient le "grabber" tel que
celui pour Amazon. On peut imaginer plein d'autres types de "grabbers", mais
celui d'Amazon est le seul port√© sous Valhalla au moment o√π j'√©cris ce billet et
il permet de "rapatrier" les couvertures CD/DVD.

## Architecture

L'architecture de la biblioth√®que √† √©t√© profond√©ment chang√©e. Trois nouveaux
threads ont fait leur apparition et sont visibles dans l'image ci-dessous en
tant que "Dispatcher", "Grabber" et "Downloader".

[![](/img/valhalla-internals.png)](/img/valhalla-internals.png)

L'image correspond au code, n√©anmoins elle est un petit peu simplifi√©e afin
d'√™tre suffisamment lisible et compr√©hensible. Le Dispatcher peut √™tre vu comme
un switch r√©seau. Son but et d'√™tre tr√®s r√©actif (il ne fait donc pas grand
chose) et de transmettre les "paquets" au bon endroit en fonction de l'√©tat de
celui-ci. Un "paquet" est une analogie au r√©seau, mais finalement dans le cas de
libvalhalla, ce n'est rien de plus qu'une structure qui d√©fini un fichier.

Afin de bien comprendre l'architecture, je vais d√©tailler le chemin effectu√© par
un paquet. Lorsque le scanner trouve un fichier sur le disque, il "l'empacte" et
le transmet au DBManager. Le DBManager va interroger la base de donn√©e pour
savoir si ce fichier existe d√©j√†, si oui il v√©rifie la date de derni√®re
modification et ignore ce paquet si cette date n'a pas chang√©e, autrement (ou si
le fichier n'existe pas dans la base), il transmet le paquet au Dispatcher. Un
paquet doit suivre 4 √©tapes avant d'√™tre d√©truit.

- **√âtape 0: `PARSING`**  
  R√©cup√©ration des m√©ta-donn√©es √† l'aide d'FFmpeg
- **√âtape 1: `GRABBING`**  
  R√©cup√©ration de nouvelles donn√©es et (ou) fichiers texts (XML) √† l'aide d'un
  ou de plusieurs grabbers
- **√âtape 2: `DOWNLOADING`**  
  T√©l√©chargement des fichiers indiqu√©s par le(s) grabber(s) (couvertures CD par
  exemple)
- **√âtape 3: `ENDING`**  
  Finalisation et destruction du paquet

Le processus pour un paquet se r√©sume donc en :

`Scanner -> DBManager -> Dispatcher -> Parser -> Dispatcher -> Grabber -> Dispatcher -> Downloader -> Dispatcher -> DBManager -> Scanner.`

Ce qui est **faux** en r√©alit√©, mais l'id√©e est correcte. L'int√©r√™t de pr√©senter
le processus aussi simplement est uniquement l√† pour permettre de comprendre par
la suite comment valhalla fonctionne. Si un paquet suivrait vraiment le
processus ci-dessus, le syst√®me serait extr√™mement lent (j'exag√®re peut √™tre sur
le mot "extr√™me") mais il faut garder en t√™te que travailler avec des grabbers
√ßa ne peut que ralentir, surtout s'il y a beaucoup de grabbers et s'ils font des
acc√®s sur internet.

## Comme un pipeline

Si le Dispatcher, le Parser, le Grabber et le Downloader sont sur des threads
diff√©rents ce n'est pas juste pour pouvoir traiter plusieurs paquets en
parall√®les, mais aussi pour pouvoir traiter un m√™me paquet √† plusieurs endroits
en m√™me temps. L'id√©e est donc de r√©cup√©rer les donn√©es "pars√©es" et "grabb√©es"
aussi vite que possible dans la base de donn√©e. Ainsi m√™me si un paquet n'a pas
finit de suivre toutes les √©tapes du processus, il est qu'en m√™me possible
d'aller chercher les informations dans la base de donn√©es.

> Pour ceux qui connaissent un peu les architectures des processeurs, ils
> connaissent √©galement la repr√©sentation en [pipeline][2] du cycle d'ex√©cution
> des instructions. J'ai vais donc expliquer le syst√®me par un dessin selon ce
> principe.

[![](/img/valhalla-pipeline4.png)](/img/valhalla-pipeline4.png)

Ce pipeline pr√©sente 4 fichiers trait√©s par deux parsers parall√©lis√©s. Il y a
chaque fois deux grabbers en s√©rie pour chaque fichier, avec un downloader √† la
fin du processus.

Les t√¢ches des threads de Valhalla fonctionnent en tant que FIFO (√† ne pas
confondre avec l'ordonnanceur du noyau). Le premier arriv√© est donc le premier
servi. Chaque fichier de ce pipeline peut √™tre s√©par√© en deux lignes. C'est ce
qui arrive lorsqu'un grabber est en marche et que des m√©ta-donn√©es doivent √™tre
sauv√©es dans la base de donn√©e. C'est cela qui permet d'avoir un temps de
r√©action int√©ressant. Il est inutile d'attendre que le processus soit termin√©
pour avoir les m√©ta-donn√©es. Par exemple avec le "FILE 0", le Scanner (jaune)
transmet le paquet au DBManager (rose p√¢le), qui va le transmettre au Dispatcher
(gris) afin d'√™tre "pars√©" (rose). Puis le paquet revient au Dispatcher et se
voit transf√©r√© dans deux threads, le grabber (vert) et le DBManager. A ce moment
l√† il se passe deux choses, le DBManager va ins√©rer les m√©ta-donn√©es du Parser
dans la base de donn√©e et en m√™me temps le grabber va commencer √† traiter les
nouvelles m√©ta-donn√©es. Puis au "grabbing" suivant, c'est les m√©ta-donn√©es du
grabber pr√©c√©dent qui sont sauv√©es quand le deuxi√®me grabber s'appr√™te √† traiter
les nouvelles m√©ta-donn√©es. Au final c'est lors de l'√©tape du downloading que
les derni√®res m√©ta-donn√©es sont sauv√©es. En r√©sum√©, chaque case DBManager (de
demi-hauteur) correspond √† une insertion dans la base de donn√©e. Dans le cadre
de cet exemple, il y a donc trois insertions par fichier (le parser + les deux
grabbers).

> J'ai omis quelques informations sinon cet article serait 5 fois plus long.

Il faut √©galement prendre le diagramme avec des pincettes car il est impossible
de pr√©dire la forme exacte pour plusieurs raisons. Les cases "parser", "grabber"
et "downloader" en particulier sont tr√®s disproportionn√©es. Leur temps est une
question de plusieurs dizaines de millisecondes √† plusieurs secondes. Tout
d√©pend de la taille des fichiers, du demuxer utilis√© par FFmpeg, de la vitesse
de votre connexion internet, du temps sur les acc√®s aux disque dur, etc, ‚Ä¶ Le
dispatcher se contente de quelques microsecondes, et dans le diagramme il prend
autant de temps que le DBManager ce qui est absurde. Au premier abord on
pourrait penser qu'il y a beaucoup de trous dans ce pipeline, mais en r√©alit√©
les trous sont bien plus grand que √ßa si vous consid√©rez qu'un parser prend 3
secondes pour un fichier. N√©anmoins ce n'est pas du tout un probl√®me (d'ailleurs
s'il n'y avait pas de trous alors tous vos CPU seraient constamment √† 100%; il
ne faut pas oublier non plus que dans certaines √©tapes il y a des temps morts
tel que les acc√®s au disque dur et sur internet).

Si vous regardez bien le diagramme, vous voyez des trous importants apr√®s les
√©tapes "parser". En fait, le scan du disque, le parsing et l'insertion des
m√©ta-donn√©es des parsers vont se faire tr√®s vite. A la m√™me vitesse qu'avant
l'ajout des grabbers dans Valhalla. Les grabbers ont aucun impacte sur les
parsers car ils sont ex√©cut√©s apr√®s eux. Ce n'est pas plus compliqu√© que √ßa.

Il faut √©galement interpr√©ter ce diagramme d'un point de vue plus large.
Imaginez le avec plus de 100 lignes (ou plus), ce qui peut arriver sans probl√®me
lorsqu'un scanner passe sur un de vos dossiers de musique. Cela donnerait
visuellement tous les parsers qui descendraient √† gauche en un escalier serr√©,
et les grabbers seraient parsem√©s (avec des trous importants dans toutes les
lignes). N√©anmoins il peut y avoir des grabbers non utilis√©s par certains
fichiers, voir m√™me aucun grabber, ce qui complique fortement le diagramme.

## Quelques pr√©cisions

- Il y a de la documentation avec les en-t√™tes de libvalhalla afin de savoir
  comment impl√©menter un grabber, mais je donerais des informations sur ce blog
  un de ces 4.

- L'application `test-valhalla` permet de tester les grabbers. Il suffit de lire
  l'aide de la commande.

- Valhalla peut √™tre compil√© sans le support des grabbers, ainsi les fichiers
  passent de l'√©tape 0 `PARSING` √† l'√©tape 3 `ENDING`. La biblioth√®que r√©agira
  exactement comme avant l'ajout des grabbers.

- Il manque √©galement des √©l√©ments pour une utilisation dans Enna, le fichier
  `TODO` vous en dira plus.

Voil√†, je n'ai pas la motivation d'en dire plus aujourd'hui, rien que de
dessiner le pipeline √ßa m'a pris pas mal de temps. Je reviendrais donc sur
certains aspects dans un prochain billet.

A bient√¥t,  
Mathieu SCHROETER

[1]: http://en.wikipedia.org/wiki/Hei%C3%B0r%C3%BAn
[2]: http://en.wikipedia.org/wiki/Pipeline_(computing)
