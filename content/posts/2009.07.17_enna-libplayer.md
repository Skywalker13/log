---
title: "Un bug particulier avec Enna/libplayer ~ ğŸ‡«ğŸ‡·"
date: 2009-07-17
tags: [geexbox, enna, libplayer]
description: "Un bug un peu particulier"
draft: true
---

Hello,

comme je lâ€™ai plus dâ€™une fois expliquÃ©, la vidÃ©o sous Enna passe par libplayer.
Et depuis quelque temps, Ben et Nico mâ€™ont Ã  nouveau sensibilisÃ© sur un problÃ¨me
dâ€™aspect avec les vidÃ©os. Le plus simple des aspects correspond Ã  une stupide
fraction:

$$\textbf{aspect}=\frac{\textbf{largeur}}{\textbf{hauteur}}$$

Mais celle-ci _nâ€™est pas toujours vraie_, ainsi lâ€™aspect peut Ãªtre directement
enregistrÃ© en tant que propriÃ©tÃ© dans le fichier vidÃ©o. Un exemple courant Ã©tant
les films DVD. La dÃ©finition de lâ€™image est de 720Ã—576 (PAL) nÃ©anmoins lâ€™aspect
peut Ãªtre du 4:3, 16:9 ou du cinÃ©mascope 2.39:1. Pourtant lâ€™image est toujours
enregistrÃ©e afin dâ€™utiliser un maximum de surface et donc les pixels ne sont pas
carrÃ©s. ConsidÃ©rer le pixel carrÃ© est le dernier recours au cas oÃ¹ la vidÃ©o ne
donnerait aucune information sur son aspect.

## Le bugâ€¦

<img src="/img/enna.png" />

Le problÃ¨me rencontrÃ© part Ben et Nico nâ€™Ã©tait pas reproductible chez moi. Et
Ã©tant principalement responsable de libplayer depuis toutes les modifications
que jâ€™ai apportÃ©, et donc connaissant de fond en comble sa structure et son
fonctionnement actuel, il est forcÃ©ment de mon devoir que de corriger les
problÃ¨mes connus. Quand ils utilisaient libplayer avec Enna, ils avaient
certaines vidÃ©os qui sâ€™affichaient avec un aspect de 1.00. Ce qui engendre donc
une image parfaitement carrÃ©e. Sâ€™ils testaient cette mÃªme vidÃ©o avec le logiciel
test-player qui utilise libplayer, lâ€™aspect Ã©tait correcte. LÃ  oÃ¹ Ã§a devenait
encore plus Ã©trange, câ€™est quand jâ€™ai testÃ© la mÃªme vidÃ©o que Nico et jâ€™avais un
aspect correct aussi bien sous Enna que sous test-player. Je ne savais donc pas
comment reproduire le bug, mÃªme que jâ€™avais de plus en plus de doute sur
lâ€™existence de ce bug. Non pas que je nâ€™ai pas confiance en leurs manipulations
(surtout quâ€™ils sont deux Ã  Ãªtre victime de ce problÃ¨me) mais plutÃ´t que je fais
toujours une grande quantitÃ© de testes lorsque jâ€™ajoute ou modifie des
fonctionnalitÃ©s dans la bibliothÃ¨que. Les problÃ¨mes dâ€™aspect je les ai
particuliÃ¨rement travaillÃ© quand jâ€™ai rajoutÃ© le support de la navigation DVD
pour les wrappers MPlayer et xine. Car il y a des conversions de coordonnÃ©es Ã 
effectuer pour que la souris agissent au bon endroit sur la surface de lâ€™image
et cela en tenant compte de lâ€™aspect et des offsets en x et y.

Nico mâ€™a alors transmis les logs Enna lorsque le problÃ¨me survient et jâ€™ai pu
identifier le problÃ¨me indirectement. libplayer Ã©crit dans ses logs certaines
informations sur les modifications quâ€™il effectue sur la fenÃªtre vidÃ©o. Il
apparait que la ligne qui indique lâ€™aspect de lâ€™image utilisait une virgule pour
sÃ©parer les dÃ©cimales. Sur mon ordinateur cette mÃªme ligne ne sâ€™Ã©crit pas avec
une virgule, mais avec un point.

## Un problÃ¨me de [LOCALE][1]

libplayer utilise abondamment la fonction atof() pour la conversion des valeurs
rÃ©elles transmissent par MPlayer. Une de ces valeurs est lâ€™aspect. MPlayer
retourne la valeur dans un champ ID_VIDEO_ASPECT=1.85 par exemple. Et ce champ a
toujours un point comme dÃ©limiteur dans le cas dâ€™un MPlayer utilisÃ© avec
libplayer (MPlayer doit toujours Ãªtre en anglais). LÃ  oÃ¹ Ã§a devient un problÃ¨me
câ€™est le comportement de la fonction atof(). En fonction de la LOCALE du
systÃ¨me, elle considÃ¨re que le dÃ©limiteur est une virgule et non un point. De ce
fait, (et surtout parce que la fonction atof() ne peut pas Ã©chouer) lâ€™aspect lu
nâ€™Ã©tait pas 1.85, mais 1. atof() ignorait tous les caractÃ¨res depuis le point.

Bien quâ€™Ã©tant de langue francophone, en Suisse-Romande nous nâ€™avons pas du tout
la mÃªme LOCALE que la France. Notre clavier est Ã©galement diffÃ©rent (disposition
QWERTZ). Nous utilisons le point comme sÃ©parateur de dÃ©cimale et non la virgule
et la LOCALE est â€œfr_CHâ€. En France, la LOCALE est â€œfr_FRâ€ et le sÃ©parateur de
dÃ©cimale est une virgule. Ceci explique pourquoi je ne pouvais pas reproduire
lâ€™erreur. Qui pense aux LOCALEs quand il y a un bug sur lâ€™aspect des vidÃ©os? Et
bien je tÃ¢cherais dâ€™y penser Ã  partir de maintenant. Quoi quâ€™il en soit, de
nombreux franÃ§ais devaient avoir des problÃ¨me, mais je nâ€™ai pas eu dâ€™autres
retours que les autres dÃ©veloppeurs. Je suppose que les Ã©ventuels utilisateurs
dâ€™Enna se sont dit quâ€™Ã©tant donnÃ© quâ€™aucune version stable existe, Ã§a finirait
par Ãªtre fixÃ© pour la finale? Sachez quâ€™il y a un site oÃ¹ vous pouvez rapporter
les problÃ¨mes: [enna.geexbox.org][2], vÃ©rifiez si le bug est dÃ©jÃ  listÃ© et dans
le cas contraire nâ€™hÃ©sitez pas Ã  vous inscrire et Ã  soumettre un rapport de bug.

## Correction

Pour y remÃ©dier il suffit donc de changer de LOCALE avec libplayer. Mais il nâ€™y
a pas de raison apparente de changer la LOCALE pour toute la bibliothÃ¨que. Ainsi
il suffit de rÃ©Ã©crire une fonction `atof()` qui sâ€™exÃ©cute dans une autre LOCALE.
En principe un programme utilise la LOCALE â€œCâ€. Qui est celle par dÃ©faut. Enna
Ã©tant internationalisÃ©, la LOCALE change selon la langue. Ceci explique donc
pourquoi le bug apparaissait sous Enna mais pas sous test-player.

En principe, la LOCALE se change avec la fonction `setlocale()`. Mais avant de
dire youpie il faut garder Ã  lâ€™esprit que libplayer utilise abondamment les
threads. Lorsque la fonction `atof()` est appelÃ©e, Enna peut Ãªtre en train de
faire autre chose. Et cet autre chose peut trÃ¨s bien Ãªtre influencÃ© par la
LOCALE en cours. Le fait dâ€™utiliser la fonction `setlocale()` modifie la LOCALE
pour tout le processus. Il est donc nÃ©cessaire dâ€™avoir recours Ã  une fonction
qui ne modifie la LOCALE que sur le thread oÃ¹ `atof()` est exÃ©cutÃ©. Cette
fonction sâ€™appelle `uselocale()`, le nouveau `atof()` se prÃ©sente donc ainsi
(patch libplayer):

```c
#define _GNU_SOURCE
#include <locale.h>
#include <stdlib.h>

double
my_atof (const char *nptr)
{
  double res;
  locale_t new_locale, prev_locale;

  new_locale = newlocale (LC_NUMERIC_MASK, "C", NULL);
  prev_locale = uselocale (new_locale);
  res = atof (nptr);
  uselocale (prev_locale);
  freelocale (new_locale);

  return res;
}
```

Afin de simplifier la fonction et dâ€™Ã©viter `atof()` qui a une rÃ©putation
dâ€™obsolescence je lâ€™ai remplacÃ© par `strtod_l()`. Du mÃªme coup il est possible
dâ€™Ã©liminer `uselocale()` et donc de ne plus changer la LOCALE du thread.

```c
#define _GNU_SOURCE
#include <locale.h>
#include <stdlib.h>

double
my_atof (const char *nptr)
{
  double res;
  locale_t new_locale;

  new_locale = newlocale (LC_NUMERIC_MASK, "C", NULL);
  res = strtod_l (nptr, NULL, new_locale);
  freelocale (new_locale);

  return res;
}
```

> On notera que `strtod()` peut retourner `HUGE_VAL` contrairement Ã  `atof()`.

A bientÃ´t,  
Mathieu SCHROETER

[1]: https://en.wikipedia.org/wiki/Locale
[2]: http://enna.geebox.org
