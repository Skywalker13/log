---
title: "Travailler seul sur du code source ferm√© ~ üá´üá∑"
date: 2023-09-01
tags: [c]
description: "‚Ä¶ du code bugg√© que personne ne regarde"
draft: false
---

Il y a longtemps, quand j'√©tais apprenti (en 2002), mon patron de stage me
tenait t√™te √† propos de Linux et du libre en g√©n√©ral. Pour lui Linux avait √©t√©
cr√©√© par une bande d'√©tudiants et donc que ce syst√®me ne pouvait pas √™tre digne
d'int√©r√™t. Il √©tait d√©j√† tr√®s clair pour moi qu'il parlait en toute ignorance.
Et depuis plus de 20 ans, je suis totalement convaincu que le code source ouvert
et libre de projets cons√©quents est toujours de bien meilleur qualit√© que ne le
sera jamais aucun code source ferm√©. Dans cet article je vais justement en
parler pour un cas de figure malheureusement typique, auquel j'ai √©t√© confront√©
il y a quelques semaines.

## Au d√©but, il y avait une seule personne

J'ai du r√©aliser des adaptations dans un projet (une migration). Le code source
que je vais vous montrer ici a √©t√© √©crit il y a plusieurs ann√©es et est utilis√©
(aujourd'hui m√™me) en production.

Je me permet de le pr√©senter ici car, quand je suis tomb√© dessus, ce code m'a
√©touff√© (et pourtant il est tr√®s court). Je veux en parler car je trouve qu'il
repr√©sente parfaitement ce qu'on ne devrait pas faire et que c'est alors un
excellent cas d'√©cole. Cel√† montre aussi l'importance d'avoir toujours au moins
une personne pour jeter √† oeil √† ce que l'on fait. Le "code review" est
indispensable et justement, dans le monde du libre tel que Linux, c'est une
√©tape obligatoire contrairement √† des projets ferm√©s o√π les d√©veloppeurs peuvent
y faire √† peu pr√™t tout et surtout n'importe quoi.

### La fonction

Voici ce qui me fait mal aux yeux. Peut √™tre que ce n'est pas le cas pour vous
et j'en suis navr√©. Mais si vous regardez mieux cette fonction vous pourriez y
trouver assez vite des probl√®mes.

Je n'ai m√™me pas besoin de chercher plus loin que **la premi√®re ligne**. Je vais
aborder pas √† pas ce que je pense √™tre des probl√®mes et comment je vais les
r√©soudre.

> Ce qu'il faut savoir avant de commencer, c'est que cette fonction C doit
> retourner 1 si le processus est en cours d'ex√©cution, sinon elle doit
> retourner 0. Elle peut aussi retourner d'autres valeurs en cas d'erreurs.

```c++
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (processId != 0) {
    auto res = kill(processId, 0);

    if (res == 0) {
      char procNameByPidBuffer[1024];
      int ret = wine_epsitec_get_native_process_name_by_pid(
          processId, procNameByPidBuffer, 1024);

      if (ret == 0) {
        // No process with the pid has been found
        return 0;
      } else if (ret == 1) {
        // Process with pid has been found, but what about its name?
        if (strstr(procNameByPidBuffer, processName) == NULL) {
          // Process with pid found, but different name
          return 0;
        }
      } else {
        // An error occurred
        return ret;
      }
    } else {
      int errsv = errno;
      if (errsv == ESRCH) {
        // Process with pid is not running
        return 0;
      } else {
        return errsv;
      }
    }
  }

  return 1;
}
```

### Qu'est-ce que je vois ?

Je me dis tout de suite, "Oh non, pas encore... ?!". Ici il y a des imbrications
de `if` qui semblent suivrent la pens√©e du d√©veloppeur qui a √©crit le code. Ce
que je veux dire c'est que (pour moi en tout cas) il y a deux grandes phases
tr√®s rapproch√©es √† l'√©criture de n'importe quel code source. D'abord il y a le
cheminement que l'on a dans la t√™te et que l'on souhaite retranscrire en code,
ensuite il y a la r√©organisation du code pour le rendre clair.

Dans le code pr√©sent√© ci-dessus, j'imagine que le d√©veloppeur l'a √©crit comme il
l'a pens√© et √† saut√© l'√©tape de nettoyage. C'est typique de code √©crit
rapidement (dans le rush). Tout juste test√© pour les quelques cas n√©cessaires √†
ce moment l√†. Bref, c'est juste du code bacl√© (et surtout, bugg√©).

Bien entendu, il est normal d'impl√©menter comme on pense, mais rapidement il
faut revenir sur le code pour le rendre lisible et efficace. C'est pendant cette
phase (n√©glig√©e ici) qu'on d√©couvre les bugs que la pens√©e du moment ne
permettait pas d'imaginer. Je vous propose alors de faire ce travail avec moi,
√©tape par √©tape.

## Guard Clause Pattern

Vous vous rappelez de Gandalf face au Balrog ? Et bien c'est le [Guard Clause
Pattern][3]. C'est certainement mon pattern pr√©f√©r√© et malheureusement pas assez
mis en pratique. Je vous donne une d√©finition par ChatGPT qui r√©sume tr√®s bien
ce que c'est.

> Le "[Guard Clause Pattern][3]", √©galement connu en fran√ßais sous le nom de
> "Motif de Clause de Garde", est un concept de programmation qui consiste √†
> utiliser des conditions pr√©liminaires pour v√©rifier rapidement et traiter les
> cas d'erreurs ou de conditions inattendues avant d'entrer dans le corps
> principal d'une fonction ou d'une m√©thode. Il vise √† am√©liorer la lisibilit√©
> du code en √©vitant des niveaux excessifs d'indentation et en traitant les cas
> exceptionnels en premier. En r√©sum√©, il s'agit d'une technique de gestion des
> erreurs et des conditions sp√©ciales au d√©but d'une fonction pour rendre le
> code plus clair et plus facile √† comprendre.
>
> -- ChatGPT-3.5

J'ai appris cette technique dans les ann√©es 2006-2009 quand je travaillais au
sein du projet GeeXboX. Un des d√©veloppeurs l'appliquait dans tout ce qu'il
faisait. Ca m'a s√©duit et j'essaie aussi de l'appliquer autant que possible
depuis lors, et j'esp√®re que j'arriverai ici √† convaincre les plus sceptiques.

Pour en revenir √† la fonction initiale et √† cette fameuse "premi√®re ligne" avec
ce `if`, c'est d'effectuer ledit exercice.

> A chaque √©tape, je donne des explications ainsi que le `diff` associ√© aux
> modifications, puis la fonction compl√®te.

### 1. Inversions de conditions

On inverse les conditions afin de sortir au plus vite en cas d'erreur.
`processId != 0` devient `!processId` (certains pr√©f√®re `processId == 0`, c'est
comme vous pr√©f√©rez).

```diff
@@ -6,3 +6,5 @@
 int is_native_process_running(int processId, LPCSTR processName) {
-  if (processId != 0) {
+  if (!processId)
+    return 1;
+
     auto res = kill(processId, 0);
@@ -35,3 +37,2 @@
       }
-    }
   }
```

Avec cette op√©ration, le `return 1` tout √† la fin est un peu confus. On le
laisse pour le moment car on y reviendra plus tard.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  auto res = kill(processId, 0);

  if (res == 0) {
    char procNameByPidBuffer[1024];
    int ret =
        get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

    if (ret == 0) {
      // No process with the pid has been found
      return 0;
    } else if (ret == 1) {
      // Process with pid has been found, but what about its name?
      if (strstr(procNameByPidBuffer, processName) == NULL) {
        // Process with pid found, but different name
        return 0;
      }
    } else {
      // An error occurred
      return ret;
    }
  } else {
    int errsv = errno;
    if (errsv == ESRCH) {
      // Process with pid is not running
      return 0;
    } else {
      return errsv;
    }
  }

  return 1;
}
```

Juste en faisant cette inversion, quelque chose de bizarre apparait. Quand
`processId` vaut 0, la fonction retourne 1. Cette fonction consid√®re que le
processus 0 est en cours d'ex√©cution. Uh ?! Le processus 0 ??? On a notre
premier bug, mais continuons avec `if (res == 0)`.

### 2. Inversions de conditions et simplifications

On inverse aussi cette condition et on voit clairement qu'en erreur, on va
forc√©ment sur un `return`; simplifions tout cel√†.

```diff
@@ -11,3 +11,9 @@

-  if (res == 0) {
+  if (res) {
+    int errsv = errno;
+    if (errsv == ESRCH)
+      return 0; // Process with pid is not running
+    return errsv;
+  }
+
     char procNameByPidBuffer[1024];
@@ -29,11 +35,2 @@
     }
-  } else {
-    int errsv = errno;
-    if (errsv == ESRCH) {
-      // Process with pid is not running
-      return 0;
-    } else {
-      return errsv;
-    }
-  }
```

Avec cette op√©ration on visualise bien le [Guard Clause Pattern][3]. La gestion
des erreurs se d√©place naturellement vers le haut de la fonction.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  auto res = kill(processId, 0);

  if (res) {
    int errsv = errno;
    if (errsv == ESRCH)
      return 0; // Process with pid is not running
    return errsv;
  }

  char procNameByPidBuffer[1024];
  int ret =
      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

  if (ret == 0) {
    // No process with the pid has been found
    return 0;
  } else if (ret == 1) {
    // Process with pid has been found, but what about its name?
    if (strstr(procNameByPidBuffer, processName) == NULL) {
      // Process with pid found, but different name
      return 0;
    }
  } else {
    // An error occurred
    return ret;
  }

  return 1;
}
```

### 3. Variable inutile et l'op√©rateur ternaire

Il y a une variable inutile (`errsv`) et on peut √©galement utiliser un op√©rateur
[ternaire][4].

```diff
@@ -9,10 +9,6 @@

+  // If errno == ESRCH, process with pid is not running
   auto res = kill(processId, 0);
-
-  if (res) {
-    int errsv = errno;
-    if (errsv == ESRCH)
-      return 0; // Process with pid is not running
-    return errsv;
-  }
+  if (res)
+    return errno == ESRCH ? 0 : errno;
```

Le code devient bien plus conscis.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  // If errno == ESRCH, process with pid is not running
  auto res = kill(processId, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  char procNameByPidBuffer[1024];
  int ret =
      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

  if (ret == 0) {
    // No process with the pid has been found
    return 0;
  } else if (ret == 1) {
    // Process with pid has been found, but what about its name?
    if (strstr(procNameByPidBuffer, processName) == NULL) {
      // Process with pid found, but different name
      return 0;
    }
  } else {
    // An error occurred
    return ret;
  }

  return 1;
}
```

Bien, regadons ce bout de code. Il est un peu bizarre, vous ne trouvez pas ? Si
[errno][2] est diff√©rent de `ESRCH` alors on le retourne. Mais cette fonction,
d'apr√®s l'auteur, est cens√©e retourner 1 si le processus est en cours
d'ex√©cution. Est-ce qu'il faut comprendre que [errno][2] ne peut jamais prendre
la valeur 1 ?

Et bien c'est un bug, quand [errno][2] vaut 1 cel√† signifie que l'erreur `EPERM`
s'est produite. Cette erreur est g√©n√©r√©e par exemple, si vous utilisez cette
fonction avec un processus d'un utilisateur o√π vous n'avez pas les droits. Par
hasard ici, ca fonctionne presque. Imaginez que vous voulez savoir si le PID 1
est en cours d'ex√©cution. Vous n'avez pas les droits, et donc `EPERM` est g√©n√©r√©
(avec la valeur 1). La fonction dit que ce processus est en cours d'ex√©cution.

> Alors oui, c'est bien le cas sinon on n'aurait pas re√ßu le code 1. Donc oui,
> le PID 1 est bien en cours d'ex√©cution, mais...

On arrive au bug suivant. L'argument `processName` n'a pas √©t√© compar√©. En
effet, cette fonction utilise `processName` pour d√©terminer si un processus d'un
certain PID, contient le nom pass√© en param√®tre pour dire si oui ou non ce
processus est en cours d'ex√©cution. La raison est simple. Quand un processus se
termine, il est tout √† fait possible qu'un autre processus prenne sa place avec
un PID identique. Se fier uniquement au PID n'est pas suffisant.

En conclusion pour ce bug on peut dire que cette fonction retourne 1 avec
n'importe quel nom de processus d√®s le moment qu'on n'a pas les droits pour lui
envoyer des signaux POSIX.

Je vous propose qu'on garde ce bug au chaud et qu'on continue le nettoyage. On y
reviendra plus loin dans cet article.

### 4. Un else avec un return; inutile et confus

On prend le `if` suivant qui nous montre que `ret == 0` est une sortie. Il y a
un `return` imm√©diatement apr√®s. On enl√®ve ce `else` inutile qui alt√®re la
lecture.

```diff
@@ -18,6 +18,6 @@

-  if (ret == 0) {
-    // No process with the pid has been found
-    return 0;
-  } else if (ret == 1) {
+  if (!ret)
+    return 0; // No process with the pid has been found
+
+  if (ret == 1) {
     // Process with pid has been found, but what about its name?
```

Ici on n'a vraiment rien chang√©.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  // If errno == ESRCH, process with pid is not running
  auto res = kill(processId, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  char procNameByPidBuffer[1024];
  int ret =
      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

  if (!ret)
    return 0; // No process with the pid has been found

  if (ret == 1) {
    // Process with pid has been found, but what about its name?
    if (strstr(procNameByPidBuffer, processName) == NULL) {
      // Process with pid found, but different name
      return 0;
    }
  } else {
    // An error occurred
    return ret;
  }

  return 1;
}
```

Pour la suite, on part du principe que la fonction
`get_native_process_name_by_pid` n'est pas bugg√©e.

### 5. Double if avec un else invisible car noy√© par l'accolade

Le `if (ret == 1)` est bien un cas de succ√®s. Il y a par contre un double `if`
pas tr√®s heureux car il y a un chemin (avec le second `if`, quand la condition
est `false`) qui demande de scanner avec l'oeil jusqu'en bas de la fonction. Je
vous invite ici √† revoir le code original (tout au sommet de cet article), o√π se
scan avec l'oeil est bien plus p√©nible. M√™me si ce code est correcte, la logique
est cach√©e dans la cascade. Alors on va simplifier...

```diff
@@ -21,9 +21,7 @@

-  if (ret == 1) {
     // Process with pid has been found, but what about its name?
-    if (strstr(procNameByPidBuffer, processName) == NULL) {
       // Process with pid found, but different name
+  if (ret == 1 && !strstr(procNameByPidBuffer, processName))
       return 0;
-    }
-  } else {
+
     // An error occurred
@@ -31,4 +29 @@
   }
-
-  return 1;
-}
```

Avec ce changement, on profite de supprimer le dernier `return` qui ne fait plus
de sens.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  // If errno == ESRCH, process with pid is not running
  auto res = kill(processId, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  char procNameByPidBuffer[1024];
  int ret =
      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

  if (!ret)
    return 0; // No process with the pid has been found

  // Process with pid has been found, but what about its name?
  // Process with pid found, but different name
  if (ret == 1 && !strstr(procNameByPidBuffer, processName))
    return 0;

  // An error occurred
  return ret;
}
```

Bien, stoppons nous ici pour r√©fl√©chir. La fonction qui rend `ret` est en
r√©alit√© aussi bugg√©e. Admettons qu'elle soit corrig√©e. Elle rend 0 ou 1 quand
tout va bien, le reste sont des erreurs. Alors traitons l'erreur avant tout.

### 6. Garder le meilleur pour la fin

On peut tr√®s simplement fusionner le cas du retour (de `ret`) √† 0 ou `!= 1` car
seul le cas 1 indique qu'il faut continuer √† chercher si le processus est bien
en cours d'ex√©cution. Le test suivant `ret == 1` devient inutile.

```diff
@@ -18,4 +18,6 @@

-  if (!ret)
-    return 0; // No process with the pid has been found
+  // No process with the pid has been found (ret == 0), or an error occured if
+  // it's not 1
+  if (ret != 1)
+    return ret;

@@ -23,7 +25,6 @@
   // Process with pid found, but different name
-  if (ret == 1 && !strstr(procNameByPidBuffer, processName))
+  if (!strstr(procNameByPidBuffer, processName))
     return 0;

-  // An error occurred
-  return ret;
+  return 1;
 }
```

Ainsi la variable `ret` n'est plus propag√©e jusqu'√† la fin de la fonction.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  // If errno == ESRCH, process with pid is not running
  auto res = kill(processId, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  char procNameByPidBuffer[1024];
  int ret =
      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

  // No process with the pid has been found (ret == 0), or an error occured if
  // it's not 1
  if (ret != 1)
    return ret;

  // Process with pid has been found, but what about its name?
  // Process with pid found, but different name
  if (!strstr(procNameByPidBuffer, processName))
    return 0;

  return 1;
}
```

### 7. Le ternaire, √©ternel alli√©

On va faire encore de la poutze. Utilisons un [ternaire][4]... Il suffit dans ce
cas de v√©rifier le nom du processus. Si le nom est trouv√© on retourne 1, sinon
on retourne 0.

```diff
@@ -24,7 +24,3 @@
   // Process with pid has been found, but what about its name?
-  // Process with pid found, but different name
-  if (!strstr(procNameByPidBuffer, processName))
-    return 0;
-
-  return 1;
+  return strstr(procNameByPidBuffer, processName) ? 1 : 0;
 }
```

N'est-ce pas plus √©l√©gant ? Certains iraient m√™me plus loin et √©criraient :

```c
return !!strstr(procNameByPidBuffer, processName);
```

Je vous √©parge cette √©criture pour cette fois. N√©anmoins c'est une fa√ßon tout √†
fait reconnue par les experts en C pour produire un bool√©en.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int processId, LPCSTR processName) {
  if (!processId)
    return 1;

  // If errno == ESRCH, process with pid is not running
  auto res = kill(processId, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  char procNameByPidBuffer[1024];
  int ret =
      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);

  // No process with the pid has been found (ret == 0), or an error occured if
  // it's not 1
  if (ret != 1)
    return ret;

  // Process with pid has been found, but what about its name?
  return strstr(procNameByPidBuffer, processName) ? 1 : 0;
}
```

J'esp√®re que vous √™tes d'accord avec moi, que cette fonctionne commence √†
ressembler √† quelque chose. On peut encore faire plus de poutze.

### 8. Attention, auto en C ce n'est pas auto de C++

Les variables `ret` et `res` sont des `int` alors simplifions. On d√©place les
d√©clarations au sommet, on renomme l'√©vidence (le mot `process` dans le nom des
variables est redondant avec le nom de la fonction) et on calcul la taille du
tableau avec `sizeof`.

```diff
@@ -5,4 +5,7 @@
  */
-int is_native_process_running(int processId, LPCSTR processName) {
-  if (!processId)
+int is_native_process_running(int pid, LPCSTR name) {
+  int res;
+  char procName[1024];
+
+  if (!pid)
     return 1;
@@ -10,3 +13,3 @@
   // If errno == ESRCH, process with pid is not running
-  auto res = kill(processId, 0);
+  res = kill(pid, 0);
   if (res)
@@ -14,13 +17,10 @@

-  char procNameByPidBuffer[1024];
-  int ret =
-      get_native_process_name_by_pid(processId, procNameByPidBuffer, 1024);
-
   // No process with the pid has been found (ret == 0), or an error occured if
   // it's not 1
-  if (ret != 1)
-    return ret;
+  res = get_native_process_name_by_pid(pid, procName, sizeof(procName));
+  if (res != 1)
+    return res;

   // Process with pid has been found, but what about its name?
-  return strstr(procNameByPidBuffer, processName) ? 1 : 0;
+  return strstr(procName, name) ? 1 : 0;
 }
```

J'ai √©galement enlev√© le mot clef `auto`. En effet, ici c'est de l'ignorance du
d√©veloppeur qui a √©crit ce code. Le modificateur `auto` en C n'a absolument pas
la m√™me signification que `auto` en C++. En C, `auto` indique que la variable
d√©clar√©e doit √™tre local (c'est implicite). En C++, `auto` sert √† faire de la
d√©duction automatique du type.

Si le code ci-dessus fonctionne c'est uniquement parce qu'en C, ne pas sp√©cifier
de type est √©quivalent √† `int` et par hasard c'est bien ce que l'on souhaite.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int pid, LPCSTR name) {
  int res;
  char procName[1024];

  if (!pid)
    return 1;

  // If errno == ESRCH, process with pid is not running
  res = kill(pid, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  // No process with the pid has been found (ret == 0), or an error occured if
  // it's not 1
  res = get_native_process_name_by_pid(pid, procName, sizeof(procName));
  if (res != 1)
    return res;

  // Process with pid has been found, but what about its name?
  return strstr(procName, name) ? 1 : 0;
}
```

Vous vous rappelez ? Je vous avais dis de garder un bug au chaud. Le bug qui
fait en sorte que la fonction retourne toujours 1 si [errno][2] vaut `EPERM`.
Mais avant de le r√©gler, on va s'occuper du bug au point 1.

### 9. Le PID 0 n'existe pas

S'il n'y a pas de PID, il faut retourner 0 et certainement pas 1. Le PID 0 ne
peut pas exister, c'est une certitude.

```diff
@@ -10,3 +10,3 @@
   if (!pid)
-    return 1;
+    return 0;
```

---

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int pid, LPCSTR name) {
  int res;
  char procName[1024];

  if (!pid)
    return 0;

  // If errno == ESRCH, process with pid is not running
  res = kill(pid, 0);
  if (res)
    return errno == ESRCH ? 0 : errno;

  // No process with the pid has been found (ret == 0), or an error occured if
  // it's not 1
  res = get_native_process_name_by_pid(pid, procName, sizeof(procName));
  if (res != 1)
    return res;

  // Process with pid has been found, but what about its name?
  return strstr(procName, name) ? 1 : 0;
}
```

Que faire avec `EPERM` ? Voici une proposition qui ne casse pas l'[ABI][1].

### 10. Errno ou moins errno ?

Quand [errno][2] n'est pas `ESRCH`, alors on retourne [-errno][2] ainsi on a
plus du tout de confusion entre la valeur 1 du succ√®s avec le code d'erreur
`EPERM`. Mais avant de tester `ESRCH`, on s'assure que [errno][2] ne vaut pas
`EPERM`. L'id√©e est simple, si on re√ßoit `EPERM` alors le processus existe, il
faut continuer pour v√©rifier son nom.

```diff
@@ -13,5 +13,7 @@
   // If errno == ESRCH, process with pid is not running
+  // if errno is EPERM == 1: Operation not permitted, we know that
+  //   the process exists, then we continue
   res = kill(pid, 0);
-  if (res)
-    return errno == ESRCH ? 0 : errno;
+  if (res && errno != EPERM)
+    return errno == ESRCH ? 0 : -errno;
```

D√©sormais on est s√ªr de ne plus jamais retourner 1 en cas d'erreur avec la
fonction `kill`.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int pid, LPCSTR name) {
  int res;
  char procName[1024];

  if (!pid)
    return 0;

  // If errno == ESRCH, process with pid is not running
  // if errno is EPERM == 1: Operation not permitted, we know that
  //   the process exists, then we continue
  res = kill(pid, 0);
  if (res && errno != EPERM)
    return errno == ESRCH ? 0 : -errno;

  // No process with the pid has been found (ret == 0), or an error occured if
  // it's not 1
  res = get_native_process_name_by_pid(pid, procName, sizeof(procName));
  if (res != 1)
    return res;

  // Process with pid has been found, but what about its name?
  return strstr(procName, name) ? 1 : 0;
}
```

On pourrait s'arr√™ter l√† mais j'aime enlever le bruit.

### 11. Moins de bruit s'il vous pla√Æt

Initialisons les variables avec une cha√Æne vide et `res` √† 0.

```diff
@@ -6,4 +6,4 @@
 int is_native_process_running(int pid, LPCSTR name) {
-  int res;
-  char procName[1024];
+  int res = 0;
+  char procName[1024] = {0};
```

Ici vous voyez l'astuce pour initialiser un tableau avec la valeur 0. On √©vite
ainsi d'avoir du bruit qui pourrait ressembler √† une cha√Æne de caract√®res.

```c
/***********************************************************************
 *           is_native_process_running
 *
 * Return if a native process is currently running, given its pid and name.
 */
int is_native_process_running(int pid, LPCSTR name) {
  int res = 0;
  char procName[1024] = {0};

  if (!pid)
    return 0;

  // If errno == ESRCH, process with pid is not running
  // if errno is EPERM == 1: Operation not permitted, we know that
  //   the process exists, then we continue
  res = kill(pid, 0);
  if (res && errno != EPERM)
    return errno == ESRCH ? 0 : -errno;

  // No process with the pid has been found (ret == 0), or an error occured if
  // it's not 1
  res = get_native_process_name_by_pid(pid, procName, sizeof(procName));
  if (res != 1)
    return res;

  // Process with pid has been found, but what about its name?
  return strstr(procName, name) ? 1 : 0;
}
```

## Pour conclure

Je vous invite √† reprendre sous les yeux la fonction originale et de la comparer
avec la derni√®re version. La version corrig√©e respecte le [Guard Clause
Pattern][3] et est beaucoup plus lisible. Les retours interm√©diaires servent √†
sortir pour dire que le processus n'est pas en fonctionnement ou qu'il y a une
erreur non g√©r√©e. Le vrai cas de succ√®s est fait uniquement dans le tout dernier
retour de la fonction.

Le second point notable vient de la gestion des erreurs de type [errno][2]. En
faisant [-errno][2] on √©vite de confondre `EPERM` avec le succ√®s de la fonction
(quand le processus existe et que le nom correspond).

D'un point de vue cosm√©tique, on a √©limin√© beaucoup de niveaux d'indentations
qui n'apportaient que de la confusion, et cel√† parce qu'on a suivit le [Guard
Clause Pattern][3].

Quoi qu'il en soit, nous avons am√©lior√© la fonction tout en √©vitant de casser
l'[ABI][1]. Il faudrait n√©anmoins pr√©venir les utilisateurs de cette fonction,
que les erreurs sont d√©sormais retourn√©es uniquement en tant qu'entier n√©gatifs
et qu'ils correspondent √† [-errno][2].

Pour √™tre encore plus propre, il faudrait s√©parer l'information bool (0..1) des
codes d'erreur. Une de ces deux information devrait √™tre rendu par r√©f√©rence
afin de ne pas m√©langer le tout dans un seul et m√™me `int`.

[1]: https://en.wikipedia.org/wiki/Application_binary_interface
[2]: https://nuetzlich.net/errno.html
[3]: https://en.wikipedia.org/wiki/Guard_(computer_science)
[4]: https://en.wikipedia.org/wiki/Ternary_conditional_operator
