---
title: "Les SmartId ~ üá´üá∑"
date: 2024-12-13
tags: [database]
description: "ou l'importance des identifiants dans une base de donn√©es"
draft: false
---

Il y a une bonne dizaine d'ann√©es, un de mes amis et coll√®gue, Samuel, a imagin√©
une repr√©sentation pour les identifiants d'entit√©s et de services, qui sont
simples, et particuli√®rement pratiques. Je vais vous les pr√©senter ici mais tout
d'abord, parlons un peu de mod√©lisation.

## La bonne vieille mod√©lisation de grand-papa

Il existe de nombreuses th√©ories mais souvent elles se ressemblent toutes. On a
[Merise][1] de nos amis fran√ßais, on a l'[UML][2] ou encore les
[diagrammes¬†ER][3], etc. Dans le fond, c'est toujours la m√™me id√©e. On cr√©e des
relations entre des entit√©s et on se pose la question suivante :

Est-ce que j'ai une relation 1-1 ou n-n (1-n, n-1, 0-n, etc.)¬†?

En fran√ßais :

> Est-ce que mon entit√© doit avoir un lien avec une seule entit√© √©trang√®re ou √†
> une collection d'entit√©s¬†?

Selon les outils, les langages, etc., il y a diff√©rentes fa√ßons de le faire mais
contentons-nous de quelques diagrammes tr√®s simples qui permettent de r√©sumer
tr√®s rapidement de quoi on parle.

---

[![1-1](/img/merise-1-1.png)](/img/merise-1-1.png)

Une clef √©trang√®re permet de r√©f√©rencer B depuis A.

---

[![n-n](/img/merise-n-n.png)](/img/merise-n-n.png)

Une table d'allocation permet de relier les A avec les B.

---

J'utilise le terme "table d'allocation" qui vient de [Merise][1]. Mais on peut
aussi parler de table de relations, de liens, de correspondances, ou que
sais-je. Ce n'est pas tr√®s important ici. Je ne sais pas pour vous, mais c'est
ce genre de m√©thode que j'ai appris, et je les ai appliqu√© un certain temps avec
g√©n√©ralement des bases de donn√©es SQL.

Cette mani√®re de faire a ses m√©rites comme pouvoir poser des contraintes
d'int√©grit√© r√©f√©rentielles par exemple. Mais... pour autant que tout soit g√©r√©
dans la m√™me base de donn√©es.

Et pourtant, comme c'est p√©nible de g√©rer des migrations de mod√®les (sch√©mas).
Personne ne fait le mod√®le parfaitement adapt√© du premier coup. Vaut mieux
limiter autant que possible les modifications.

## Le [NoSQL][4]

J'aime beaucoup cette mani√®re de faire. Au lieu d'avoir un mod√®le rigide, on a
un mod√®le beaucoup plus simple au niveau du sch√©ma de la base de donn√©es. Grosso
modo, on veut simplement retrouver des documents en fonction d'identifiants. Les
mod√®les de ces documents ne sont pas forc√©ment connus par le moteur de la base
de donn√©es. Les migrations se font au niveau des documents et pas au niveau du
sch√©ma de la base.

Au premier abord, on pourrait penser que c'est un pas en arri√®re par rapport √†
la mani√®re plus traditionnelle... et pourtant.

## Rester int√®gre

Imaginons un document A qui r√©f√©rence un document B. On a alors une relation de
type 1-1. Mais au lieu d'avoir des tables SQL, on a simplement deux documents
dans une table unique. Le document A contient un champ (une clef √©trang√®re) avec
l'id du document B.

Si j'efface le document B, je casse la relation et le moteur de la base de
donn√©es ne peut pas le voir. Dans ce sc√©nario, il y a un probl√®me majeur.
Celui-ci peut sembler surprenant pour certaines personnes mais le probl√®me,
c'est tout simplement le fait d'effacer un document. Il ne faut pas les effacer.
Ce n'est pas plus compliqu√© que √ßa. Il n'est donc pas possible de casser une
r√©f√©rence. Facile, non¬†?

> Hein¬†? Ne jamais rien effacer¬†? H√© mec, c'est n'importe quoi...

Du calme, nous ne sommes plus en 1990. L'espace de stockage n'est pas un
probl√®me, ni les performances d'ailleurs. Il faut repenser l'effacement. Dans
notre univers, on doit suivre la fl√®che du temps toujours dans le m√™me sens. Ce
qui veut dire qu'effacer un document revient √† ne plus le pr√©senter car
finalement, dans le pass√©, il a exist√©. Ainsi on le fait simplement en lui
donnant un statut. Par exemple, "trashed". En lui donnant ce statut, on dit
qu'on arr√™te sa fl√®che du temps. De cette mani√®re on pourrait m√™me le
ressusciter un jour.

## Le temps

Quand on m'a appris la mod√©lisation de base de donn√©es, on ne m'a jamais rien
appris sur le temps. Et pourtant, c'est fondamental.

Comment g√©rer le temps avec une mod√©lisation classique √† la [Merise][1],
[UML][2], etc.¬†? Mmmh... dur dur... Je ne dis pas que c'est impossible mais vous
allez transpirer. Mais en [NoSQL][4], c'est d'une tr√®s grande simplicit√© et
voici pourquoi.

Chaque entit√© est un document (par exemple un [JSON][5]) avec un identifiant. Ce
document, vous le stockez dans une table du type clef/valeur. Tr√®s important, la
clef ne doit pas avoir de contrainte unique. Chaque mutation de l'entit√© doit
ins√©rer une nouvelle entr√©e dans cette table. Il est important que l'ordre
d'insertion soit garanti. Le temps¬†? C'est simplement l'axe Y (les lignes).
Effacer un document revient alors √† ins√©rer √† la suite ce document avec le
statut "trashed".

> Effacer, c'est cr√©er une nouvel √©tat du document.

Ce que je vous pr√©sente ici, c'est une version simplifi√©e de ce qu'on a mis en
place avec Samuel. Chaque insertion est immuable, on peut uniquement aller de
l'avant.

## La suppression

Oui, il existe une situation o√π on peut supprimer d'anciennes entr√©es (d'anciens
documents). Ce sont des situations tr√®s diff√©rentes car on va parler ici de
maintenance et de garbage collector. √âtant donn√© qu'on ne fait qu'ins√©rer du
neuf, on peut supprimer de l'ancien sans impacter les utilisateurs. Le sc√©nario
est du genre de ne pas garder toutes les mutations qui existent quand elles sont
plus anciennes de 2 mois (par exemple). On peut imaginer garder que le dernier
√©tat. Et selon les types d'entit√©s, on pourrait choisir des conditions
diff√©rentes. On peut m√™me tout garder pour toujours. Tout d√©pend des documents
concern√©s, de l'activit√© par type de document, etc. Mais attention, on garde
toujours au moins le dernier m√™me si son statut est "trashed". √Ä moins que votre
garbage collector soit capable de garantir qu'il n'y a plus aucun document qui y
fait r√©f√©rence.

## Et les SmartId dans tout √ßa¬†?

J'avais besoin de passer par une introduction pour que les SmartId prennent du
sens. Nous avons donc une base de donn√©es qui contient des documents dans une
table sous la forme clef/valeur. Un document de m√™me ID peut appara√Ætre
plusieurs fois (axe temporel). Pour faire des r√©f√©rences entre les documents, on
peut :

- Ajouter une propri√©t√© dans le document A qui contient l'id du document B (1-1)
- Avoir une collection d'ID de documents B dans le document A (1-n)

C'est bien mais parfois c'est ennuyeux. On doit modifier le mod√®le du document A
pour qu'il puisse stocker une r√©f√©rence au document B. Ce n'est pas toujours
souhaitable et √ßa demande potentiellement de la migration.

## Qu'est-ce que le SmartId¬†?

Pour avoir un SmartId minimal, il faut 2 choses. Il faut un type et il faut un
texte ou num√©ro unique par type. Imaginons que le document est un message. Nous
avons le type "message". Nous pouvons utiliser un [UUID][6] pour la partie
unique. Par exemple :

- `message@8b05f82c9294483ab4ba5a7961f2e923`

Mais on peut aussi utiliser ce qui nous arrange :

- `message@99000`
- `message@main`

Utiliser un [UUID][6] donne une garantie d'unicit√©. Utiliser un mot comme "main"
permet de diff√©rencier une des entit√©s. Ce qui veut dire que vous pouvez
m√©langer diff√©rentes sortes d'identifiants tant que vous garantissez qu'il ne
peut pas y avoir de conflit. En ayant "main" et des [UUID][6], il est garanti
qu'il n'y aura jamais un [UUID][6] qui sera par hasard sous la forme de "main".

> Pourquoi le type dans l'id¬†?

En ayant le type dans l'id, il est possible de stocker diff√©rents types de
documents dans la m√™me base de donn√©es et sans conflits. Nous pourrions avoir
`message@main` ainsi que `user@main` dans la m√™me base. On pourrait √©viter le
type en ayant une base "message" et une base "user". Ou pas, parce que les
SmartId sont bien plus que √ßa. Chez nous, on fait les deux. Ce que je veux dire,
c'est qu'on a des bases de donn√©es par domaine et plusieurs types par domaine.
Ce que j'ai pr√©sent√© avant, ce sont les SmartId minimaux : `type@unique`. Mais
les SmartId sont composables et voici comment et pourquoi.

`type1@type2@unique`

> Mais qu'est-ce que c'est que √ßa¬†?

`journal@workitem@unique`

Voici un exemple tr√®s courant dans notre syst√®me. Nous cr√©ons un service
"journal" qui g√®re une sorte de journal pour le service "workitem".

Les SmartId ne sont pas utilis√©s que pour les entit√©s mais aussi pour les
services qui manipulent des entit√©s. `workitem@unique` est un service pour
modifier des entit√©s. Ce workitem va cr√©er un service "journal". Le service
"journal" h√©rite de l'identifiant du workitem. Ce journal ne peut exister que
pour cette instance du workitem. Ici vous pouvez alors deviner une relation
forte (uniquement avec l'ID) entre le service journal et le service workitem.

Un autre exemple avec les entit√©s. Imaginons que nous avons un type d'entit√©
"message" qui repr√©sente un message g√©n√©rique dans le syst√®me. Il est possible
que ce message existe aussi sous la forme d'un email, mais pas toujours. En
mod√©lisant, on pourrait se dire : ¬´ suffit de mettre une r√©f√©rence du message
dans l'entit√© email ¬ª. On cr√©e une relation avec le mod√®le du document. Mais
parfois ce n'est pas appropri√© de modifier le mod√®le. Simplement qu'on ne
souhaite pas polluer le mod√®le et encore moins le migrer. Pour cela, on peut
compter sur les SmartId. Quand un email est cr√©√© √† partir d'un message, on peut
alors faire :

- `message@123456789`
- `email@message@123456789`

Les SmartId nous permettent de cr√©er une d√©pendance 1-1 sans toucher aux
mod√®les. Nous avons utilis√© ce principe pour les tags sur les entit√©s. Ici, je
vais vous donner un exemple en production. Pour moi (et pas que moi), il est
exclu de toucher aux mod√®les des entit√©s pour les polluer avec des tags.

Mais on nous a demand√© d'int√©grer les tags bien apr√®s que nos mod√®les soient
r√©alis√©s. Voici comment les SmartId ont r√©solu la probl√©matique. Nous avons des
entit√©s de type "tag". Par exemple :

- `tag@wishes`
- `tag@prospect`
- `tag@supplier`

Un tag a de la couleur, un nom, une description, etc.

Nous avons des entit√©s de type "entityTags". Par exemple :

- `entityTags@contact@unique`

"entityTags" contient la liste des liens sur les tags associ√©s √† l'entit√©
`contact@unique`. Cette entit√© "entityTags" sert de table de relations. On
aurait pu nous arr√™ter l√†. Mais on a d√©cid√© d'aller plus loin.

Au lieu d'avoir une collection de `tag@` dans l'entit√© "entityTags", nous avons
une collection de `tagLink@` (oui encore un type). Un "tagLink" se pr√©sente
ainsi :

- `tagLink@contact@unique@tag@supplier`

Ce "tagLink" peut contenir des donn√©es utilisateur qui sont par exemple
introduites au moment de l'application du tag sur le contact. C'est optionnel et
tr√®s pratique. Avec ce syst√®me bas√© sur les SmartId, il est alors possible
d'assigner des tags √† n'importe quelle entit√© du syst√®me sans toucher au moindre
mod√®le et tout en pouvant assigner des donn√©es avec chaque tag pos√©. Finalement
le sch√©ma se construit avec les SmartId.

## Les liens avec l'ext√©rieur

Je souhaite encore vous pr√©senter un cas d'utilisation tr√®s pratique des
SmartId. Nous avons des syst√®mes o√π nous devons importer r√©guli√®rement des
donn√©es externes en plus de g√©rer nos propres entit√©s. Imaginons des clients
(par exemple). Le syst√®me cr√©e des clients sous la forme `customer@uuid`. Le
syst√®me externe cr√©e des clients avec des nombres auto-incr√©ment√©s. Client 1001,
1002, 1005, 1011, ... Un syst√®me traditionnel... Quand nous importons depuis ce
syst√®me, nous pouvons utiliser les SmartId ainsi (par exemple) :

- `customer@1001-extern`

Nous n'avons pas de risque de conflit avec nos propres ID et il est tr√®s facile
d'effectuer une mise √† jour. L'importateur des externes va simplement chercher
l'entit√© `customer@XXXX-extern` existante (ou la cr√©er au besoin). Sans les
SmartId, tout devient plus complexe car certainement qu'on devrait conserver
l'id extern dans le mod√®le de l'entit√© customer. En plus, la recherche de
l'entit√© √† synchroniser √† l'import se complexifie. Beurk... Merci les SmartId.

Si je ne vous ai pas convaincu ce n'est pas tr√®s grave car je ne cherche pas √†
convaincre, mais tant mieux si √ßa peut vous faire r√©fl√©chir. En ce qui me
concerne, depuis lors, je n'ai plus aucune envie de faire de la mod√©lisation √†
la fa√ßon de grand-papa.

[1]: https://fr.wikipedia.org/wiki/Merise_(informatique)
[2]: https://fr.wikipedia.org/wiki/UML_(informatique)
[3]: https://fr.wikipedia.org/wiki/Mod%C3%A8le_entit%C3%A9-association
[4]: https://fr.wikipedia.org/wiki/NoSQL
[5]: https://fr.wikipedia.org/wiki/JavaScript_Object_Notation
[6]: https://en.wikipedia.org/wiki/Universally_unique_identifier
