---
title: "Quoi de neuf sur les libs ~ üá´üá∑"
date: 2010-01-03
tags: [geexbox, libplayer, libvalhalla, xlib, xcb, vdpau]
description: "Some lib news"
draft: false
---

Hello,

maintenant qu'[Enna 0.4.0][1] est dehors et que les paquets sont disponibles,
cet article me donne l'occasion de faire un peu la synth√®se des modifications
apport√©es √† libvalhalla et √† libplayer depuis les versions 1.0.0. A noter que la
premi√®re version d'Enna concerne uniquement les versions 1.0.0, et en aucun cas
ce que je liste ci-dessous.

## libplayer

Concernant libplayer il n'y a pas grand chose de neuf. La plupart des patchs se
rapportent √† des fix mineurs dans les scripts et Makefiles. Ainsi que le support
(en th√©orie) de Darwin. Je n'ai pas la moindre id√©e si la compilation pour MacOS
X fonctionne car je n'ai jamais eu de Mac √† ma disposition. A part une image
√©mul√©e d'une Tiger qui n'est pas sp√©cialement rapide √† l'utilisation.

Mise √† part √ßa, la modification la plus importante est le remplacement de
[Xlib][2] par [XCB][3]. Xlib a toujours √©t√© un probl√®me n√©anmoins une astuce
permettait de le rendre utilisable dans le contexte de libplayer. X11 dans
libplayer a deux raisons d'√™tre. Tout d'abord c'est un bon moyen pour cr√©er une
fen√™tre X pour MPlayer. Cette fen√™tre √©tant enti√®rement contr√¥l√©e par libplayer,
cela √©vite d'avoir des probl√®mes avec les √©v√©nements X11 et il est facile de
l'embarquer dans Enna. Ensuite cette fen√™tre est indispensable pour xine-lib.

<img src="/img/xcb.png" width="150">

Le probl√®me d'Xlib intervient au niveau des threads. Afin de garantir d'√™tre
thread-safe il est n√©cessaire d'appeler la fonction `XInitThreads()` avant
n'importe quel autres fonctions d'Xlib. Ou alors, il faut g√©rer les locks sur
les appels Xlib sois-m√™me. J'ai donc opt√© pour la deuxi√®me solution (dans le cas
de `libplayer-1.0.0`). Des m√©canismes dans xine-lib permettent d'appeler les
locks cr√©√©s par libplayer. Mais il y a un point √† soulever. Selon les dires des
d√©veloppeurs de xine, ces m√©canismes ne sont pas exempt de bugs. Et
l'utilisation d'`[XInitThreads()][4]` est impossible dans le cas de libplayer.
La raison est tr√®s simple. √âtant donn√© que ce doit √™tre la premi√®re fonction √†
appeler, il faudrait √™tre s√ªr que par exemple avec [Evas][5], Qt ou GTK (si
libplayer serait utilis√© dans une application qui en d√©pend tel qu'Enna avec
Evas), que libplayer soit initialis√© avant ces libs. Ou alors qu'Evas fasse lui
m√™me un `XInitThreads()`. Ou encore que celui qui d√©veloppe le GUI (tel qu'Enna)
fasse un `XInitThreads()` dans son main() (avant toutes les autres
initialisations). Et donc l'utilisation d'une telle biblioth√®que deviendrait
tr√®s contraignante.

La solution c'est XCB. Il n'y a aucun besoin d'initialiser quoi que se sois pour
les threads contrairement √† Xlib. XCB peut donc √™tre utilis√© de mani√®re s√ªre
dans libplayer et sans fournir de locks suppl√©mentaires. C'est sur XCB que les
d√©veloppeurs de xine se tournent √©galement. Car il y a au moins les sorties
video Xshm et Xv qui sont port√©es pour XCB.

La prochaine release de libplayer utilisera donc XCB. Pour √™tre plus pr√©cis, le
fait d'utiliser XCB dans libplayer n'emp√™che pas d'utiliser Xlib pour un wrapper
de libplayer, pour autant que les m√©canismes pour garantir le thread-safe soient
impl√©ment√©s.

### VDPAU

NVidia fait des efforts pour Linux depuis longtemps. [VDPAU][6] en est un
exemple parmi d'autres. Mais tout ceci reste qu'en m√™me du code ferm√© avec tous
les d√©savantages qui en d√©coulent. Dans le cas de libplayer, il est aujourd'hui
impossible de supporter VDPAU avec xine. Non pas que xine ne peut pas
l'utiliser, mais plut√¥t que xine est oblig√© de passer par Xlib pour pouvoir
l'exploiter.

![](/img/xine.png)

On pourrait croire alors que je n'aurais pas du changer Xlib pour XCB dans
libplayer, mais en r√©alit√© √ßa n'a strictement rien √† voir. Le probl√®me est au
niveau de VDPAU. Celui-ci √©tant bas√© sur Xlib, il est n√©cessaire d'avoir
l'initialisation des locks. Le seul moyen actuel est de devoir faire appel √†
`XInitThreads()`. Ainsi xine refuse de charger VDPAU dans les seuls cas
thread-safe tel que XCB ou la variante Xlib (soit disant "bugg√©e" qui fonctionne
qu'en m√™me bien par rapport √† ce que `libplayer-1.0.0` en fait).

Pour √™tre honn√™te, il y a un moyen mais c'est un hack. En ajoutant un
`XInitThreads()` dans Enna avant l'initialisation d'Evas ainsi qu'une
modification dans le wrapper xine de libplayer pour lui dire qu'il doit
travailler avec Xlib.

> Tout ceci ne concerne pas le wrapper MPlayer, qui peut parfaitement utiliser
> VDPAU pour la sortie vid√©o comme pour les codecs, √©tant donn√© que c'est un
> processus "fork√©".

## libvalhalla

C'est sur cette biblioth√®que o√π j'ai le plus travaill√© depuis la 1.0.0. Mise √†
part des correctifs sur les scripts et Makefiles comme pour libplayer et Darwin,
il y a aussi de nouvelles fonctionnalit√©s.

### API

Tout d'abord l'API publique est maintenant plus facile √† √©tendre sans la casser
√† l'ajout de nouveaux param√®tres √† l'initialisation par exemple. J'ai √©galement
factoris√© toutes les fonctions qui permettent de configurer libvalhalla en une
seule fonction variadique.

### Statistiques

Avec libvalhalla-1.0.0 il y a d√©j√† quelques statistiques. Par exemple les
r√©sultats et les temps utilis√©s par les grabbers, ou encore un r√©sum√© des
actions qui ont √©t√© faites sur la base de donn√©e. N√©anmoins ces informations ne
sont pas disponibles depuis l'API. Ce qui change dans le prochain libvalhalla
c'est que toute les statistiques de ce type sont r√©cup√©rables facilement. Il y
en a √©galement plus qu'avant. Je dois encore en ajouter sur certaines parties
tel que le scanner. Mais les ajouts n'affecteront en rien l'API publique.

Dans le cas d'Enna √ßa pourra √™tre utilis√© pour montrer (pour le fun) l'√©tat des
diff√©rentes parties de libvalhalla dans une fen√™tre d'information. Les
statistiques peuvent √™tre interrog√©es √† n'importe quel instant, ce qui permet de
suivre l'√©volution.

### √âv√©nements globaux

Il est possible d'avoir des √©v√©nements globaux comme par exemple une information
qui pr√©vient que tous les fichiers (pour une passe compl√®te du scanner) ont √©t√©
trait√©s. Il n'y a pas beaucoup d'√©v√©nements pour l'instant. Ils ne sont pas des
plus utiles, mais dans le cas d'Enna il permettront d'avoir une notification. Il
est √©galement facile d'en ajouter des nouveaux.

### Metadata callback

C'est un callback qui a √©t√© ajout√© suite √† une proposition d'un tiers pour une
demande assez sp√©cifique. Le but est de pouvoir r√©cup√©rer depuis l'API publique
toutes les metadata en m√™me temps qu'elles sont r√©cup√©r√©es par les parsers et
grabbers. C'est donc un moyen d'avoir acc√®s aux donn√©es sans passer par la base
de donn√©e. Je ne recommande pas son utilisation pour plusieurs raisons. Tout
d'abord si le callback est bloqu√© relativement longtemps pour chaque metadata,
l'utilisation m√©moire va augmenter en fonction (le blocage du callback ne bloque
pas le reste de la biblioth√®que). Il faut absolument veiller √† traiter les
donn√©es aussi vite que possible. La deuxi√®me raison est que SQLite est beaucoup
plus performant pour rendre toutes les metadata. Les fonctions de s√©lections
sont relativement haut-niveaux et permettent de r√©cup√©rer les informations de
mani√®re efficaces et ordonn√©e. Une de ces fonctions a √©galement √©t√© un peu
am√©lior√©e dans le cadre des modifications depuis la version 1.0.0.

J'ai qu'en m√™me rajout√© la fonctionnalit√© dans la biblioth√®que car elle n'est
pas intrusive et ne peut pas introduire des r√©gressions ou des ralentissements.

### Grabbers parall√©lis√©s

C'est la plus grosse nouveaut√© pour la prochaine release. Dans le cas de
libvalhalla-1.0.0, beaucoup d'√©l√©ments travaillent en parall√®le, √† l'exception
des grabbers (entre eux). Il est possible maintenant d'avoir "autant" de
grabbers que l'on veut simultan√©ment. Cette fonctionnalit√© permet d'√©conomiser
environ 30% du temps selon mes essais. L'int√©r√™t est √©galement que les fichiers
vid√©os ne sont plus bloqu√©s sur les grabbers d√©di√©s √† l'audio et inversement.
Par exemple le grabber LyricWiki qui est sp√©cialement lent, √©tait un vrai goulot
d'√©tranglement pour les fichiers vid√©os (aussi pour les autres fichier audio, ce
qui est implicite). La parall√©lisation permet √† ces fichiers (non-audio) de se
terminer ind√©pendamment de ce grabber (et des autres).

J'ai mis la limite maximum √† 16 grabbers en parall√®le (ce qui est plus que le
nombre de grabbers diff√©rents qui existent). Un choix efficace et d'opter pour 3
ou 4. L'utilisation de la RAM n'est pas sp√©cialement affect√©e car la plupart
utilisent des services web qui sont plut√¥t gourmand en temps.

Il y a deux autres effets √† noter:

- Les priorit√©s ne sont plus compl√®tement respect√©es si on d√©fini plus d'un
  grabber √† la configuration. Ce qui veut dire que par exemple un fichier peut
  √™tre envoy√© dans un grabber qui devrait (selon les priorit√©s) √™tre interrog√©
  dans les derniers. Il est donc possible de continuer √† travailler comme
  libvalhalla-1.0.0 en for√ßant explicitement le nombre √† 1.
- Le second effet est li√© au ondemand. Celui-ci est plus rapide car il y a
  plusieurs threads de grabbers et donc il peut rapidement avoir toutes ces
  demandes sur tous les threads (√† cause des priorit√©s du ondemand).

#### Le fonctionnement en quelques mots

La parall√©lisation des grabbers n'est pas comparable √† celle des parsers.
Lorsqu'un fichier doit √™tre trait√© par un parser, il attend simplement dans la
queue jusqu'√† ce qu'un parser le POP et le traite vraiment. Il n'y a pas de
raison de faire autrement car tous les parsers font le m√™me travail. Les
grabbers sont diff√©rents car chacun d'eux fait un travail sp√©cifique. Ainsi
lorsqu'un fichier se retrouve dans la queue et qu'un thread de grabber le POP,
il va chercher un grabber de libre. Le cas √©ch√©ant il renvoi le fichier dans la
queue et r√©essaye avec le suivant. Il n'y a donc jamais de longue attente, ce
qui permet de bien encha√Æner tous les fichiers.

Il y a aussi quelques conditions. Un m√™me fichier n'est jamais parall√©lis√© entre
les diff√©rents threads des grabbers. Et un m√™me grabber travail que dans un seul
thread √† la fois. Ce qui veut dire par exemple, que s'il y a 10 threads; pour
que les 10 soient actifs il faut au moins 10 grabbers diff√©rents (FFmpeg,
LyricWiki, Amazon, etc,‚Ä¶), et 10 fichiers diff√©rents.

Il est ainsi √©vident que d'avoir beaucoup de threads n'apportent absolument plus
rien au del√† d'une certaine limite que j'estime √† environ 4. Mais ceci d√©pend
fortement des types de fichiers diff√©rents, des types de grabbers compil√©s et
leur nombre.

Bonne ann√©e,  
Mathieu SCHROETER

[1]: http://enna.geexbox.org/
[2]: http://fr.wikipedia.org/wiki/Xlib
[3]: http://fr.wikipedia.org/wiki/XCB
[4]: http://tronche.com/gui/x/xlib/display/XInitThreads.html
[5]: http://en.wikipedia.org/wiki/Enlightenment_Foundation_Libraries#Evas
[6]: http://en.wikipedia.org/wiki/VDPAU
