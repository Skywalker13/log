---
title: "De POSIX √† Windows ~ üá´üá∑"
date: 2010-02-19
tags: [posix, c, windows, hack, wine]
description: "Posix vs Windows"
draft: false
---

Hello,

La sortie d'[Enna][1] au d√©but janvier √† r√©veiller des critiques de tous les
genres. En principe (faut √™tre honn√™te) elles ne m'int√©ressent pas sp√©cialement.
Tout d'abord je n'estime pas qu'il y ait de concurrence entre les logiciels
libres. Beaucoup de projets s'inspirent d'autres projets et c'est normal. Et si
quelqu'un d√©sire une fonctionnalit√© sp√©cifique il a plusieurs solutions. La
premi√®re c'est d'utiliser le projet qui offre la fonctionnalit√© (non?). La
seconde c'est de critiquer simplement le projet car une fonctionnalit√©
**√©vidente** est absente. Se sont ces critiques l√† que j'ignore sp√©cialement,
car elles n'apportent rien. Apr√®s vous avez des gens qui critiquent mais qui
aident spontan√©ment et ils sont toujours les bienvenue.

## De "POSIX" √† Windows

Une des critique facile est de dire qu'Enna ne fonctionne pas sous Windows et
qu'[XBMC][2] par contre est multi-plateforme. Les gens qui le disent ont
tendance √† oublier (ou alors √† ne pas du tout connaitre, m√™me dans les grandes
lignes) l'histoire XBMC. Et oui, √† l'origine XBMC ne fonctionnait pas nativement
sous Linux. Le port √† pris du temps, et c'est le m√™me probl√®me quand il faut
porter dans l'autre sens.

Pour en revenir √† Enna, je n'ai aucun int√©r√™t personnel √† l'avoir sous Windows.
N√©anmoins il y a eu des progr√®s pour qu'un jour, Enna puisse fonctionner sous
Windows. Pour quand? Je n'en sais rien et √ßa n'a aucune importance.

Concernant le titre, si j'ai mis [POSIX][3] entre guillemets c'est parce que
tout n'est pas vraiment du POSIX. Certaines choses sont des extensions du GNU
par exemple. Il y a des adaptations √† faire aussi entre les syst√®mes qui se
basent sur POSIX. M√™me entre les noyaux Linux et \*BSD, voir m√™me Hurd.

> Par exemple libvalhalla fonctionne correctement sous les noyaux Linux et
> FreeBSD (je pense sp√©cialement √† [Debian GNU/kFreeBSD][4]), elle fonctionne
> aussi avec [Hurd][5] (test√© avec [Debian GNU/Hurd][6]) √† la diff√©rence que les
> priorit√©s sur les threads ne sont pas g√©r√©es correctement. Chaque noyau √† sa
> fa√ßon de faire des threads et √ßa demande de prendre en compte les cas
> particuliers.

J'ai volontairement omis de mentionner Mac OS X, ou plus pr√©cis√©ment
[Darwin][7]. Bien qu'Apple dit qu'il soit POSIX-compliant, il y a qu'en m√™me au
moins un cas particulier dans libvalhalla car ce n'est pas si POSIX que √ßa.

### MinGW

Le meilleur moyen de r√©aliser des ports Windows est sans aucun doute [MinGW][8].
C'est une base GCC et le compilateur peut √™tre natif Windows ou alors compil√©
pour une [compilation crois√©e][9] sous GNU/Linux (ou d'autres OS). En principe
depuis GNU/Linux on peut cross-compiler aussi bien pour Windows que pour Darwin
(c'est ainsi que les diff√©rentes versions du g√©n√©rateur d'ISO sont faites).
N√©anmoins, √ßa peut paraitre √©tonnant mais il est plus facile de cr√©er un
compilateur crois√© pour Windows (merci au projet MinGW) que pour Darwin.

> J'ai deux cross-compilateurs binaires pour Darwin8 (PPC et i686). Ils ont √©t√©
> cr√©√©s il y a maintenant plusieurs ann√©es par un ancien membre de GeeXboX.
> Malheureusement il est parti avec les secrets de fabrication. Je n'ai jamais
> r√©ussi √† les reproduire depuis les sources (et ce n'est pas faute d'avoir
> essay√©). Si quelqu'un √† des pistes, elles m'int√©ressent grandement!

## libgeexbox-win32

Avant d'esp√©rer Enna sous Windows il faut bien s√ªr se concentrer sur les
d√©pendances. Et ce qui nous int√©resse ici c'est donc libnfo, libplayer et
libvalhalla. Au moment o√π j'√©cris cet article, libnfo et libvalhalla sont
"compl√®tement" support√©s sous Windows. Je vais reprendre quelques √©l√©ments
int√©ressants qui ont pos√©s des probl√®mes.

> Notez les guillemets, car en ce qui concerne libvalhalla il reste un potentiel
> probl√®me. Mais n√©anmoins la biblioth√®que est utilisable.

Libvalhalla utilise des temporisations √† diff√©rents endroits. Celles-ci sont
r√©alis√©es √† l'aide de variable-conditions/mutex. L'id√©e est d'avoir des
temporisations interruptibles contrairement √† des fonctions du type `sleep()`,
`usleep()` ou `nanosleep()` (attention, je parle bien de temporisations
interruptibles sans l'aide de [signaux][10]). La biblioth√®que [Pthreads][11] de
POSIX offre tout ce dont on a besoin. Ainsi libvalhalla et libplayer reposent
compl√®tement sur celle-ci. Mais ce n'est pas directement de Pthreads que je
d√©sire parler, mais du temps pour pouvoir esp√©rer avoir des temporisations plus
ou moins pr√©cises. Les fonctions pthreads utilisent la structure
`struct timespec` qui en th√©orie offre un champ √† la nanoseconde. M√™me si la
valeur peut √™tre juste au moment de la lecture de l'horloge, les appels de
fonctions prennent de toutes fa√ßon des nanosecondes/microsecondes. Et m√™me pour
un syst√®me temps r√©el dur, c'est tr√®s difficile de jouer dans ces ordres de
grandeurs. Les seuls applications pratiques o√π je me suis vraiment amus√© √†
compter les nanosecondes c'est lorsque que je faisais du [VHDL][12] sur un bon
vieux Xilinx.

Bref.. passons.. Mon but est de pouvoir traiter des temporisations de plusieurs
centaines de millisecondes. Ce qui est tr√®s facile avec un noyau Linux. La
structure timespec √©voqu√©e pr√©c√©demment se pr√©sente ainsi.

```c
struct timespec {
  time_t sec;
  long int nsec;
}
```

Sous \*BSD, Linux et Darwin il est tr√®s facile de la peupler. Concernant Mac OS
X et son pseudo POSIX-compliant, le noyau [Mach][13] permet de r√©cup√©rer une
structure relativement semblable avec √©galement des nanosecondes, mais la
fonction POSIX `clock_gettime()` n'existe pas chez Apple. Que le champ nsec soit
juste ou non √ßa n'a pas d'importance, pour autant qu'il ne soit pas faux dans
les millisecondes. Finalement ces trois noyaux offrent les fonctions n√©cessaires
et m√™me plus. Mais on ne peut pas en dire autant de l'API Windows.

## Une question de temps

### [GetSystemTime][14]

Windows met √† disposition des fonctions nomm√©es `GetSystemTime()` et
`GetSystemTimeAsFileTime()`. Elles sont sens√©es retourner une r√©solution √† la
milliseconde, respectivement √† la centaine de nanoseconde.
`GetSystemTimeAsFileTime()` est connu comme √©tant plus rapide que
`GetSystemTime()`. Par contre cette fonction n'existe pas sous Windows CE et
perd donc de son int√©r√™t (d√®s le moment qu'on recherche la portabilit√©).

Voyez plut√¥t le r√©sultat en pratique avec mon PC.

```
 WinXP                         GNU/Linux/Wine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
GetSystemTime ()
 1266227465.000000000          1266233962.000000000
 1266227465.000000000          1266233962.000000000
 1266227465.000000000          1266233962.000000000
 1266227465.000000000          1266233962.000000000
 1266227465.000000000          1266233962.000000000
 - wait 1 ms
 1266227465.015000000          1266233962.001000000
 - wait 2 ms
 1266227465.031000000          1266233962.003000000
 - wait 3 ms
 1266227465.046000000          1266233962.006000000
 - wait 4 ms
 1266227465.062000000          1266233962.010000000
 - wait 5 ms
 1266227465.078000000          1266233962.015000000
```

A gauche il y a donc les r√©sultats directement depuis Windows XP. A droite c'est
le m√™me programme mais ex√©cut√© √† travers Wine (le m√™me PC est utilis√©). Les
attentes de 1 √† 5 ms sont r√©alis√©es simplement par la fonction `Sleep()`
√©galement mise √† disposition par l'API Windows. Il est int√©ressant de noter que
Windows n'arrive pas √† descendre √† la milliseconde avec un `Sleep(1)`. Probl√®me
connu ceci dit‚Ä¶

A noter √©galement que la fonction `GetSystemTime()` n'est pas des plus
performante. Elle est reconnue comme √©tant peu propice √† offrir r√©ellement 1 ms
de r√©solution. J'ai fais ainsi une seconde mesure avec 10'000 lectures du
compteur, pour d√©tecter la r√©solution effective.

Apr√®s plus de 8'000 lectures, Windows retourne vraiment 15 ms de plus que la
lecture pr√©c√©dente.

```
 1266484241.000000000
 1266484241.000000000
 ... ~8000 fois ...
 1266484241.000000000
 1266484241.000000000
 1266484241.015000000
 1266484241.015000000
 1266484241.015000000
 1266484241.015000000
```

### [GetSystemTimeAsFileTime][15]

J'ai donc refais les m√™mes mesures mais avec `GetSystemTimeAsFileTime()` pour
voir si on arrive √† des meilleurs r√©sultats. Le MSDN parle de 100 ns, on peut
donc esp√©rer une r√©solution utilisable √† la milliseconde.

```
 WinXP                         GNU/Linux/Wine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
GetSystemTimeAsFileTime ()
 1266227465.078125000          1266233962.015939000
 1266227465.078125000          1266233962.015941000
 1266227465.078125000          1266233962.015942000
 1266227465.078125000          1266233962.015944000
 1266227465.078125000          1266233962.015945000
 - wait 1 ms
 1266227465.093750000          1266233962.017012000
 - wait 2 ms
 1266227465.109375000          1266233962.019076000
 - wait 3 ms
 1266227465.125000000          1266233962.022139000
 - wait 4 ms
 1266227465.140625000          1266233962.026204000
 - wait 5 ms
 1266227465.156250000          1266233962.031268000
```

La premi√®re chose qui frappe ici, c'est que Windows semble donner que des
valeurs multiples de 25. Donc d'une r√©solution de 25 us. On est encore
relativement loin des 100 ns promis par le MSDN. Mais pour tester la vrai
r√©solution, j'ai √©galement fais tourner la lecture 10'000 fois.

> On constate que Wine arrive √† atteindre la microseconde. N√©anmoins on n'a pas
> non plus la r√©solution de 100 ns. La raison est que Wine se base sur la
> fonction `gettimeofday()` qui sous les syst√®mes POSIX, ne donne pas une
> r√©solution meilleure que la microseconde. La structure est un timeval au lieu
> d'un timespec avec un champ usec au lieu de nsec.

Ici aussi, apr√®s environ 8'000 lectures, on constate une r√©solution d'exactement
:

$$109.375-93.75=15.625\,ms$$

C'est aussi mauvais qu'avant. Les microsecondes n'apportent absolument rien. Au
d√©but je me suis fais avoir car je pensais vraiment que les 25 us √©taient
atteints. Et bien que la fonction est sens√©e √™tre plus rapide d'apr√®s mes
recherches, en pratique (sous Windows XP), il n'y a pas de quoi en faire une
montagne. Il a fallut presque le m√™me nombre de lecture (un peu plus de 8000)
pour environ 15 ms.

```
 1266484241.093750000
 1266484241.093750000
 ... ~8000 fois ...
 1266484241.093750000
 1266484241.093750000
 1266484241.109375000
 1266484241.109375000
 1266484241.109375000
 1266484241.109375000
```

Je pense qu'elle est consid√©r√©e comme plus rapide car elle ne peuple pas une
structure relativement complexe comme `GetSystemTime` (voir [`SYSTEMTIME`][16]).
La structure utilis√©e avec la seconde fonction est [`FILETIME`][17].

Finalement, comme premi√®re conclusion et pour garder la compatibilit√© avec
Windows CE on peut utiliser `GetSystemTime()` sans regret.

### clock_gettime

Il existe donc un moyen d'avoir une bien meilleur r√©solution. Le principe est
d'utiliser l'horloge haute r√©solution (la TSC dans les processeurs x86) afin
d'atteindre la nanoseconde. Pour ce faire, Windows met √† disposition deux
fonctions, `QueryPerformanceFrequeny()` conjointement avec
`QueryPerformanceCounter()`.

Le but final est de simuler la fonction `clock_gettime()` de POSIX qui permet
d'atteindre une r√©solution de 1 ns.

La premi√®re fonction donne la fr√©quence de l'horloge haute r√©solution et la
seconde donne le nombre de ticks depuis la mise en route. La fr√©quence donn√©e
est toujours (√† peu de chose pr√®s) un multiple de 1'193'182 Hz.

Le principe est donc de retrouver le tick qui correspond √† un temps pr√©cis
depuis [EPOCH][18]. Puis de retrouver le temps en divisant simplement le nombre
de ticks par la fr√©quence. L'horloge √©tant au minimum cadenc√©e √† 1'193'182 Hz,
on devrait avoir au moins une r√©solution de :

$$\frac{1}{1193182}=838.10\,ns$$

```
 WinXP                         GNU/Linux/Wine
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Freq: 3579545                 Freq: 1193182
 1266227465.156298915          1266233962.031381633
 1266227465.156301150          1266233962.031384147
 1266227465.156302826          1266233962.031385823
 1266227465.156304502          1266233962.031387499
 1266227465.156306178          1266233962.031389176
 - wait 1 ms
 1266227465.171900059          1266233962.032571728
 - wait 2 ms
 1266227465.187522995          1266233962.034622547
 - wait 3 ms
 1266227465.203157943          1266233962.037689975
 - wait 4 ms
 1266227465.218764954          1266233962.041754736
 - wait 5 ms
 1266227465.234392918          1266233962.046825211
```

A noter que Wine donne toujours la fr√©quence la plus basse. Cette fr√©quence
normalement d√©pend du mat√©riel, mais Wine se base sur Linux pour r√©cup√©rer le
temps. Ainsi la fr√©quence peut √™tre arbitraire. Windows XP me donne par contre
une fr√©quence pas tout √† fait correcte. Comme je l'ai dis avant, celle-ci
devrait √™tre un multiple de 1'193'182, pourtant pour que ce multiple soit vrai,
il faudrait alors 3'579'546 au lieu de 3'579'545. Je suppose que la fonction
`QueryPerformanceFrequeny()` n'arrondit pas la valeur.

On trouve ici un pas de 1676/1677 ns. Aussi bien avec Windows qu'avec Wine. Ce
qui est tr√®s bon. Le temps perdu vient d√©sormais des appels de fonctions et non
plus de l'impr√©cision des valeurs de temps.

On pourrait crier victoire, mais en r√©alit√© il y a encore un probl√®me potentiel.
L'horloge haute r√©solution est ind√©pendante. Ce qui veut dire qu'elle va
forc√©ment diverger par rapport √† l'horloge qui donne le "vrai" temps. Ainsi sur
une longue p√©riode, l'erreur entre les deux va s'agrandir lin√©airement.

> Etant donn√© que la r√©solution de `GetSystemTimeAsFileTime()` est trop
> impr√©cise pour de courtes mesures, il est n√©cessaire de faire des mesures sur
> plusieurs heures pour avoir des r√©sultats significatifs. Seul la r√©solution de
> 15.625 ms peut servir de r√©f√©rence et une telle divergence ne peut pas √™tre
> d√©tect√©e sur quelques minutes (√† moins que `QueryPerformanceCounter()` et
> `QueryPerformanceFrequeny()` soient compl√®tement faux). Je n'ai donc rien √†
> vous montrer au sujet de ce potentiel probl√®me de divergence.

### La synchronisation

Bien que je ne connaisse pas encore la divergence entre les horloges, on peu
l√©gitimement se poser la question de la resynchronisation.

Le principe est d'utiliser une information qui est fiable. Et donc a priori
c'est la seconde. L'id√©e est de r√©cup√©rer le tick qui correspond au changement
de seconde. Ensuite ce tick est converti en un temps depuis EPOCH (un temps
absolu en seconde). On m√©morise cette seconde pour toute la dur√©e de vie du
programme.

D√®s que `clock_gettime()` est appel√©, on regarde la valeur du compteur de
l'horloge haute r√©solution, puis on la soustrait √† la valeur qui correspond aux
secondes du d√©but. On a donc une diff√©rence de valeur du compteur. On la divise
par la fr√©quence du compteur ce qui nous donne la diff√©rence de temps. On
additionne ce nouveau temps avec les secondes du d√©part pour enfin avoir le
temps en nanoseconde depuis EPOCH.

Le potentiel probl√®me avec la synchronisation vient sp√©cialement du fait
d'utiliser la seconde comme r√©f√©rence. Si la synchronisation commence au d√©but
d'une nouvelle seconde, il faut attendre quasiment une seconde pour terminer la
synchronisation. Ainsi actuellement dans le libvalhalla pour Windows, il n'y a
pas de resynchronisation. En fonction du d√©calage entre l'horloge haute
r√©solution et l'horloge du temps, les timers finissent par se rentrer dedans ou
alors par devenir de plus en plus √©cart√©s. Le fait qu'ils divergent ou
convergent d√©pend du mat√©riel.

Je vois deux solutions pour le moment.

1. Faire la resynchronisation en parall√®le au reste du programme. Ainsi on peut
   continuer d'utiliser `clock_gettime()` avec la pr√©c√©dente synchronisation.
2. Synchroniser sur `GetSystemTimeAsFileTime()` avec son pas de 15.625 ms. Mais
   la compatibilit√© avec Windows CE est perdue.

Il reste aussi √† d√©terminer quand est-ce qu'il faut resynchroniser.

Un autre probl√®me vient des changements de l'heure du syst√®me. Si cela arrive,
actuellement libvalhalla aura toutes les temporisations fauss√©es sous Windows.

### Les Pthreads

Finalement, on peut se demander si tout cela vaut la peine. Les Pthreads pour
Windows ont √©t√© con√ßus pour fonctionner sur un maximum de versions de Windows.
Ainsi la r√©f√©rence de temps utilis√©e se fait via `GetSystemTime()`. Le
`clock_gettime()` utilis√© dans libvalhalla √† deux raisons d'√™tre. D'abord il
sert √† donner un temps absolu aux fonctions Pthreads, et il sert √† faire les
mesures de temps pour les statistiques. L'aberration dans tout ce travail sur un
`clock_gettime()` pour Windows est simplement que le temps donn√© aux fonctions
Pthreads est de bien meilleur r√©solution que la r√©solution du temps interne au
Pthreads-win32 (il faudrait n√©anmoins que je v√©rifie ce point, je n'ai fais que
survoler les sources de Pthreads-win32). Et avoir une r√©solution √† la
nanoseconde pour des statistiques n'apporte rien.

Un des seul int√©r√™t restant c'est donc le petit d√©fi que √ßa repr√©sente.

J'h√©site √† enlever tout le code relatif √† `QueryPerformanceCounter()` pour
n'utiliser que `GetSystemTime()` avec sa mis√©rable r√©solution. Ou alors rajouter
un test sur la fonction `GetSystemTimeAsFileTime()` pour la pr√©f√©rer √†
`GetSystemTime()` si elle existe. Tout ces probl√®mes me rappel toujours un peu
plus pourquoi Windows √† un noyau qui n'a rien de plus que les autres. Mais qui
au contraire, ne cr√©er que des probl√®mes suppl√©mentaires.

## Speedhack

Je profite de cet article pour pr√©senter les speedhacks (ces logiciels de
triches permettant par exemple de se d√©placer plus vite dans un jeu, tr√®s pris√©
√† l'√©poque sur Counter-Strike).

Si j'en parle ici c'est qu'ils reposent sur les fonctions de l'horloge haute
r√©solution, et plus pr√©cis√©ment `QueryPerformanceCounter()`. Il y a un peu plus
d'un an, j'avais √©cris un article √† ce sujet que vous pouvez lire √† [cette
adresse][19]. J'en ai profit√© pour y faire deux trois am√©liorations et
corrections.

A bient√¥t,  
Mathieu SCHROETER

[1]: http://enna.geexbox.org/
[2]: http://xbmc.org/
[3]: http://fr.wikipedia.org/wiki/POSIX
[4]: http://www.debian.org/ports/kfreebsd-gnu/
[5]: http://www.gnu.org/software/hurd/hurd.html
[6]: http://www.debian.org/ports/hurd/
[7]: http://en.wikipedia.org/wiki/Darwin_%28operating_system%29
[8]: http://www.mingw.org/
[9]: http://en.wikipedia.org/wiki/Cross_compiler
[10]: http://en.wikipedia.org/wiki/Signal_%28computing%29
[11]: http://en.wikipedia.org/wiki/POSIX_Threads
[12]: http://en.wikipedia.org/wiki/Vhdl
[13]: http://en.wikipedia.org/wiki/Mach_%28kernel%29
[14]: http://msdn.microsoft.com/en-us/library/ms724390%28VS.85%29.aspx
[15]: http://msdn.microsoft.com/en-us/library/ms724397%28VS.85%29.aspx
[16]: http://msdn.microsoft.com/en-us/library/ms724950%28VS.85%29.aspx
[17]: http://msdn.microsoft.com/en-us/library/ms724284%28VS.85%29.aspx
[18]: http://en.wikipedia.org/wiki/Unix_epoch
[19]: http://www.gamesover.ch/programmation/speedhack.r2.pdf
