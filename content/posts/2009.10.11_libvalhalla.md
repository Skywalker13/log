---
title: "Force-stop, on demand, events, ‚Ä¶ ~ üá´üá∑"
date: 2009-10-11
tags: [geexbox, libvalhalla]
description: "Strength and honor"
draft: false
---

Hello,

avec les projets GeeXboX parfois j'ai l'impression de ne jamais arriver au bout.
Quand quelque chose se termine, il y a toujours autre chose √† faire. On ne
risque pas de s'ennuyer. Mais il arrive qu'on fasse les choses √† double, triple
ou pire. Tout √ßa pour dire que les fonctionnalit√©s pr√©sent√©es dans le billet
pr√©c√©dent ("force-stop", "on demand" et "events") sont impl√©ment√©es.

> Je vous invite √† lire [l'article √† ce lien][1] si vous ne comprenez pas de
> quoi je parle; reste aussi √† √™tre int√©ress√© par ce genre d'article :-).

## En quelques phrases

### force-stop

Je ne vais pas revenir sur les d√©tails. La r√©alisation du "force-stop" a
introduit de nouvelles tables dans la base de donn√©e. Une table pour sauvegarder
les "grabbers" et une table pour sauvegarder les contextes du "downloader". En
r√©sum√©, lorsqu'un fichier a √©t√© trait√© par un "grabber" et que les donn√©es ont
√©t√© sauvegard√©es, la relation avec ce "grabber" est √©galement introduite dans la
base de donn√©e. √áa √©vite ainsi au prochain d√©marrage de "regrabber" les m√™me
donn√©es. Pour le "downloader" l'id√©e est un tout petit peu diff√©rente. Lorsque
Valhalla se termine, il sauvegarde toutes les listes de fichiers √† t√©l√©charger
dans la base de donn√©e. Au prochain d√©marrage, quand le scanner tombe sur un
fichier o√π il y avait encore des donn√©es √† t√©l√©charger, il r√©introduit les
listes dans les structures.

### ondemand

Pour le "ondemand" le travail s'est montr√© un peu plus compliqu√© que je le
pensais. √âtant donn√© que le "ondemand" peut se passer √† n'importe quel moment il
y a de nombreux cas √† consid√©rer. Par exemple, vous faites une requ√™te
"ondemand", le fichier de la requ√™te n'a pas √©t√© vu par le scanner. Le
"ondemand" se met en branle et ce fichier se retrouve dans le m√©canisme, puis le
scanner voit le fichier et l'introduit presque en m√™me temps dans le m√©canisme.
Du coup vous vous trouvez avec deux paquets diff√©rents pour un m√™me fichier. Il
y a ainsi deux-trois astuces pour g√©rer ce cas de figure ainsi que beaucoup
d'autres (je vous √©pargne le plus tordu sur lequel je suis tomb√©). Aucune
nouvelle table a √©t√© introduite pour cette fonctionnalit√©, uniquement un nouveau
champ dans la table des fichiers, pour savoir si le fichier existe dans les
chemins du scanner, ou pas. Grosso modo le "ondemand" se passe ainsi: pause de
tous les threads en aval au scanner (donc depuis le DBManager); il attend que
tout le monde s'en dort; il cherche dans les queues si le fichier √† traiter
existe d√©j√†; en fonction de √ßa il cr√©er un nouveau ou il modifie l'existant;
puis il r√©veille tout le monde. Les paquets "ondemand" ont √©galement une haute
priorit√© et sont donc trait√©s le plus rapidement possible par les diff√©rents
threads de Valhalla.

### events

Concernant les √©v√©nements, il y a simplement des retours au "front-end" pour lui
signaler quelle √©tapes ont √©t√© r√©alis√©es, via un [callback][2]. Les √©v√©nements
sont possibles uniquement avec les requ√™tes "ondemand".

## L'architecture

[![](/img/valhalla-internals.png)](/img/valhalla-internals.png)

Deux threads ont donc fait leur apparition (en rose p√¢le). L'architecture n'a
donc pas √©t√© modifi√©e, mais √©tendue. Au lieu de n'avoir que le scanner comme
intervenant pour l'ajout de fichiers, il y a donc le "ondemand" en parall√®le.
Les √©v√©nements sont trait√©s exclusivement par le DBManager.

Comme toujours, ces diagrammes sont un peu simplifi√©s. Par exemple, les
commandes "ondemand" ne sont pas bloquantes. Et donc en r√©alit√© il y a une queue
devant la fl√®che entrante du "front-end". Mais √ßa n'apportait rien d'int√©ressant
√† la lecture de ce diagramme. Il suffit de lire la documentation Doxygen pour
conna√Ætre ce genre de pr√©cision quant a l'utilisation des fonctions publiques.

## La base de donn√©e

[![](/img/valhalla-db.png)](/img/valhalla-db.png)

Les modifications sur la base de donn√©e concernent les tables `grabber`,
`dlcontext`, `file` ainsi que la table d'allocation pour les relations (n,n)
avec les "grabbers". Les champs `interrupted__` et `outofpath__` ont int√©gr√©s la
table `file`. Notez bien que les champs termin√©s par `__` sont utilis√©s
uniquement comme donn√©es internes pour le bon fonctionnement de Valhalla.

## Mais encore ‚Ä¶

Comme je le disais au d√©but, on aime faire du travail √† double et m√™me √† triple.
√âcrire des "grabbers" dans Enna pour ensuite les porter dans Valhalla. Et le
meilleur c'est quand le fournisseur d'un service utilis√© par un "grabber" aime
se foutre du monde. Amazon par exemple, un jour il d√©cide de dire que toutes les
requ√™tes pour le service doivent √™tre sign√©es [HMAC-SHA256][3] (c'est limite
ridicule mais √ßa n'engage que moi). Ou alors la [MPAA][4]/[RIAA][5] qui aime
emmerder les petits (et dire qu'ils sont pay√©s pour √ßa) et qui emp√™che ainsi
Lyricwiki de fournir une WebAPI pour les paroles des chansons. Du coup deux
"grabbers" cass√©s, le "grabber" Lyricwiki qui a √©t√© fix√© d'une autre mani√®re
mais qui s'est vu √† nouveau √™tre inutilisable (je crois, je ne m'en suis pas
occup√©).

En ce qui concerne Amazon c'est pas une grosse affaire mais j'ai la flemme.
C'est fatiguant de devoir toujours revenir sur ce qui a d√©j√† √©t√© fait, encore et
encore. Imaginez le jour o√π il y a une release. Vous aurez deux-trois "grabbers"
de morts en √† peine quelques semaines.

Finalement avant de fixer des "grabbers" mieux vaut attendre le dernier moment.

### Mais encore ‚Ä¶, ‚Ä¶

Il manque (et oui) des moyens depuis l'API publique pour modifier des
m√©ta-donn√©es; un exemple: le "play-count". Vous pouvez imaginez d'autres types
de champs dans cette id√©e. mais qui dit modifier les donn√©es dit aussi de
consid√©rer deux cas de figure:

1. Modifier uniquement dans la base de donn√©e
2. Modifier √©galement dans le fichier en question (avec FFmpeg)

Selon les m√©ta-donn√©es et le type de fichier, seul le cas (1.) est envisageable.
Mais pour par exemple un OGG et l'artiste, il peut √™tre bien de pouvoir
directement l'√©crire dans le fichier. Tout ceci reste encore sujet √† r√©flexion.

A bient√¥t,  
Mathieu SCHROETER

[1]: /posts/2009.08.23_grabbers/
[2]: http://fr.wikipedia.org/wiki/Fonction_de_rappel
[3]: http://fr.wikipedia.org/wiki/HMAC
[4]: http://fr.wikipedia.org/wiki/MPAA
[5]: http://fr.wikipedia.org/wiki/RIAA
