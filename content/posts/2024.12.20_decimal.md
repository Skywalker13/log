---
title: "Les nombres r√©els en informatique ~ üá´üá∑"
date: 2024-12-13
tags: [math, c, c#, python, javascript]
description: "Au-del√† du r√©el"
draft: false
---

- [Mais qu‚Äôest-ce que le type double](/posts/2024.12.20_decimal/#mais-quest-ce-que-le-type-double)
  - [La virgule flottante](/posts/2024.12.20_decimal/#la-virgule-flottante)
- [Et si on parlait d‚Äôargent](/posts/2024.12.20_decimal/#et-si-on-parlait-dargent)
- [Ne plus jamais perdre en pr√©cision](/posts/2024.12.20_decimal/#ne-plus-jamais-perdre-en-pr√©cision)
  - [Une solution ce sont les fractions rationnelles](/posts/2024.12.20_decimal/#une-solution-ce-sont-les-fractions-rationnelles4)
  - [Conserver la valeur exacte tout en ayant l‚Äôarrondi](/posts/2024.12.20_decimal/#conserver-la-valeur-exacte-tout-en-ayant-larrondi)
- [Certains langages proposent le type decimal](/posts/2024.12.20_decimal/#certains-langages-proposent-le-type-decimal)
- [En conclusion](/posts/2024.12.20_decimal/#en-conclusion)

---

Qui ne sait jamais confront√© aux probl√®mes d'arrondis avec les nombres r√©els¬†?
Prenons un exemple tout simple. Dans n'importe quel langage de programmation qui
utilise la virgule flottante, l'√©quation suivante (si simple au premier abord)
ne donne pas le r√©sultat esp√©r√©.

$$\frac{1}{98}\times98=1$$

**Javascript**

```js
console.log(`${(1.0 / 98.0) * 98.0}`); // 0.9999999999999999
```

**Langage C**

```c
#include <stdio.h>
int
main(void)
{
  double number = 1.0;
  number /= 98.0;
  number *= 98.0;
  printf("%.16lf", number); // 0.9999999999999999
  return 0;
}
```

**Langage C#**

```c#
double number = 1.0;
number /= 98.0;
number *= 98.0;
Console.WriteLine(number); // 0.9999999999999999
```

## Mais qu'est-ce que le type double

Tous ces r√©sultats seraient tr√®s perturbants pour quelqu'un sans connaissance
pouss√©e en informatique. D'une certaine mani√®re, c'est m√™me inqui√©tant si on
souhaite utiliser un ordinateur comme calculateur en physique. Il est donc tr√®s
important de comprendre ce qui se passe en d√©tail dans la machinerie et pourquoi
le r√©sultat de cette √©quation si trivial, n'est pas exacte.

Commen√ßons par comprendre ce qui se passe avec la division¬†:

$$\frac{1}{98}=0.0\overline{102040816326530612244897959183673469387755}$$

Le r√©sultat de cette √©quation rend un nombre r√©el avec une partie p√©riodique de
42 d√©cimales. Na√Øvement on pourrait penser que le fait qu'il y ait une p√©riode,
forc√©ment l'ordinateur ne peut pas contenir un nombre r√©el d'une longueur
infini. Mais cette explication n'est pas compl√®te car ici on repr√©sente les
nombres en base 10 et pas en base 2. Prennons un exemple encore plus simple avec
un nombre sans partie p√©riodique et demandons √† nos langages de programmation ce
qu'il en est.

$$0.1$$

**Javascript**

```js
console.log(`${0.1}`); // 0.1
```

**Langage C**

```c
#include <stdio.h>
int
main(void)
{
  double number = 0.1;
  printf("%.16lf", number); // 0.1000000000000000
  return 0;
}
```

**Langage C#**

```c#
double number = 0.1;
Console.WriteLine(number); // 0.1
```

> Oufff, √ßa fonctionne‚Ä¶

Vous pensez vraiment que tout est bon ? H√© bien il y a un pi√®ge. Tous ces
r√©sultats sont apparemment correctes, mais pourtant ils apparaissent juste
uniquement parce qu'on a de la chance avec les arrondis. Demandons √† nos
langages d'augmenter le nombre de d√©cimales visibles.

**Javascript**

```js
console.log(`${(0.1).toFixed(32)}`); // 0.10000000000000000555111512312578
```

**Langage C**

```c
#include <stdio.h>
int
main(void)
{
  double number = 0.1;
  printf("%.32lf", number); // 0.10000000000000000555111512312578
  return 0;
}
```

**Langage C#**

```c#
double number = 0.1;
Console.WriteLine(string.Format("{0:F32}", number)); // 0.10000000000000000555111512312578
```

Comme vous pouvez alors le constater, la vraie valeur 0.1 n'existe pas. Un
ordinateur ne peut pas repr√©senter ce chiffre r√©el de mani√®re exacte.

### La virgule flottante

Un nombre r√©el comme 0.1 doit √™tre converti au format binaire avec une [virgule
flottante][1]. C'est une repr√©sentation num√©rique limit√©e par le nombre de bits
√† disposition. Par exemple le type double utilise 64 bits.

1. **(S)** Le signe (1 bit) qui dit si le nombre est positif ou n√©gatif
2. **(E)** L'exposant (11 bits) qui est un ensemble de bits repr√©sentant la
   puissance de base √† laquelle la mantisse doit √™tre multipli√©e
3. **(M)** La mantisse (52 bits) qui est un ensemble de bits qui repr√©sente la
   partie significative du nombre

La virgule flottante correspond √† la [notation scientifique][9] qu'on utilise
habituellement en math√©matiques.

Un nombre √† virgule flottant se calcul ainsi¬†:

$$(-1)^{s}\times1.M\times2^{E-Biais}$$

Pour 0.1¬†:

$$(-1)^{0}\times1.6\times2^{-4}=0.1$$

Pour trouver 1.6 (la mantisse) il faut effectuer une conversion d√©cimale-binaire
en utilisant une m√©thode assez simple. On multiplie par 2 et on prend la partie
enti√®re du r√©sultat, puis on r√©p√®te ce processus avec la partie fractionnaire
restante.

- 0.1 \* 2 = 0.2 (partie enti√®re = 0)
- 0.2 \* 2 = 0.4 (partie enti√®re = 0)
- 0.4 \* 2 = 0.8 (partie enti√®re = 0)
- 0.8 \* 2 = 1.6 (partie enti√®re = 1)
- 0.6 \* 2 = 1.2 (partie enti√®re = 1)
- 0.2 \* 2 = 0.4 (partie enti√®re = 0)
- 0.4 \* 2 = 0.8 (partie enti√®re = 0)
- 0.8 \* 2 = 1.6 (partie enti√®re = 1)
- 0.6 \* 2 = 1.2 (partie enti√®re = 1)
- 0.2 \* 2 = 0.4 (partie enti√®re = 0)
- 0.4 \* 2 = 0.8 (partie enti√®re = 0)
- 0.8 \* 2 = 1.6 (partie enti√®re = 1)
- 0.6 \* 2 = 1.2 (partie enti√®re = 1)
- ‚Ä¶

Avec 0.1, ce processus ne se termine jamais et produit une s√©quence infinie de
bits¬†: 0.00011001100110011‚Ä¶ 0.1 est alors un nombre avec [une partie d√©cimale
p√©riodique][3] sous la forme binaire. La mantisse normalis√©e va ressembler √†
1.100110011001100110011‚Ä¶ (on d√©cale simplement la virgule comme on le ferait en
base 10 avec la [notation scientifique][9])

Il est alors impossible d'avoir une repr√©sentation exacte en base 2 car nous
avons un nombre limit√© de bits √† disposition. Un nombre qui nous semble tr√®s
simple en base 10, ne l'est pas forc√©ment en base 2.

## Et si on parlait d'argent

La finance est un domaine sujet aux arrondis et donc √† de la perte de pr√©cision.
Le probl√®me vient simplement du centime qui repr√©sente l'unit√© de la monnaie.
Que faire quand on doit distribuer de l'argent quand on a de la perte de
pr√©cision¬†? Prennons un exemple tout simple. J'ai 3 amis √† qui je dois partager
un billet de 10 CHF. Voici quelques solutions √† cette probl√©matique.

1. Je d√©coupe le billet en trois parts √©gales avec une paire de ciseaux  
   Je doute que mes amis soient tr√®s content mais avec cette technique je peux
   avoir une tr√®s grande pr√©cision.
2. Je donne 3.33 CHF √† chacun de mes amis, et je garde 1 centime pour moi
3. Je donne 3.33 CHF √† deux de mes amis, et √† celui que je pr√©f√®re je lui donne
   3.34 CHF

A part la premi√®re solution, les deux autres sont satisfaisantes dans ce
contexte car je peux produire des factures √† ce moment l√† pour figer les
transactions; mais compliquons l'exemple.

Pendant 10 mois, il sera comptabilis√© 10/3 CHF pour chacun d'eux. Apr√®s 10 mois
ils recevront l'argent.

$$10\times\frac{10}{3} = 33.(3)$$

Il n'y a pas de facture interm√©diaire. En effet, mes amis vont recevoir
uniquement le montant final.

Chaque mois, il y a un montant de 10/3 CHF qui est ajout√© √† chaque compte. Si je
stock le r√©sultat de l'op√©ration j'ai forc√© un arrondi. C'est un probl√®me
habituel en finance. On stock les r√©sultats et pas les √©quations pour y arriver.

> Peut √™tre avez-vous quelques souvenirs de vos cours de math√©matiques. Combien
> de fois le professeur vous a dit que les r√©sultats ne l'int√©resse pas, c'est
> uniquement l'√©quation qui importe.

Admettons que je travail de mani√®re traditionnel. Mon syst√®me stock les
r√©sultats au centime et donc je partage le billet de 10 CHF en part de 3.33 CHF.

|         | 1¬†Jan. | 1¬†F√©v. | 1¬†Mar. | 1¬†Avr. | 1¬†Mai | 1¬†Jun. | 1¬†Jui. | 1¬†Ao√ª. | 1¬†Sep. | 1¬†Oct. | Perte |
| ------- | ------ | ------ | ------ | ------ | ----- | ------ | ------ | ------ | ------ | ------ | ----- |
| Par¬†ami | 3.33   | 6.66   | 9.99   | 13.32  | 16.65 | 19.98  | 23.31  | 26.64  | 29.97  | 33.30  | 0.03  |

Le 1er octobre il y a 10 centimes qui n'ont jamais √©t√© distribu√©s (chaque mois
il y a un centime qui "saute" √† cause de l'arrondi). Il faudrait au moins
distribuer encore 9 centimes (car 10 n'est pas disivible par 3). Le dernier
centime, je peux le garder dans ma poche.

Et si on avait simplement travaill√© en double sans forcer d'arrondi au centime¬†?

Dans ce cas on aurait trouv√© quelque chose comme 33.3333333‚Ä¶ car en double on a
une bonne pr√©cision. Avec l'arrondi final on a donc bien r√©cup√©r√© les 3 centimes
manquants. C'est mieux mais √ßa ne suffit pas. On ne fait que repousser le
probl√®me en augmentant la pr√©cision.

Prennons par exemple cette √©quation¬†:

$$100\times(0.01 + 0.02 + 0.3) = 33$$

On manipule ici 100 fois 33 centimes. Ca n'a rien d'extraordinaire, pourtant
m√™me en double on perd trop en pr√©cision et notre calcul est fauss√© √† cause des
additions.

`100 * (0.01 + 0.02 + 0.3) = 32.99999999999999`

Bien entendu, avec un arrondi on y arrive mais arrondir ne permet pas toujours
de s'en sortir quand on cumule beaucoup d'op√©rations. On peut finir par avoir
une erreur d'un centime presque impossible √† expliquer. Alors pourquoi continuer
√† travailler avec des nombres √† virgule flottante¬†?

## Ne plus jamais perdre en pr√©cision

Maintenant que vous savez qu'il ne faut pas se fier aveugl√©ment aux nombres √†
virgule flottantes, alors comment pouvons-nous r√©gler cette question une bonne
fois pour toute. Un moyen simple de ne jamais perdre en pr√©cision c'est de tout
simplement stocker vos nombres sous la forme de cha√Ænes de caract√®res. Revenons
√† notre exemple avec 0.1. Si je stock `"0.1"` au lieu du double 0.1, je donne
une garantie de pr√©cision.

Que dire de notre tout premier exemple avec la division de 1 par 98¬†? Nous
pouvons aussi tenter une repr√©sentation sous forme de cha√Æne de caract√®res. Par
exemple `"0.0(102040816326530612244897959183673469387755)"`. Cette
repr√©sentation nous donne exactement le r√©sultat de la division sans perte de
pr√©cision car la partie p√©riodique est repr√©sent√©e par les parenth√®ses.

Je ne sais pas pour vous, mais pour moi ce n'est pas compl√®tement satisfaisant.
Bien que les nombres soient exactes, c'est surtout le second cas qui me d√©range
un peu. Et si on utilisait des repr√©sentation fractionnaires¬†? Pour 0.1, on
pourrait l'√©crire aussi sous la forme d'une cha√Æne de caract√®res mais en tant
que fraction `"1/10"`. Avec le second cas on aurait alors simplement `"1/98"`.

Je pense que vous √™tres d'accord avec moi. Utiliser `"1/98"` au lieu de
`"0.0(102040816326530612244897959183673469387755)"` c'est bien plus pratique, et
en plus √ßa prend beaucoup moins de place. Le second avantage, c'est que dans le
cas de nos fractions, si nous consid√©rons supporter uniquement des [nombres
rationnels][4], alors le num√©rateur et le d√©nominateur seront toujours des
entiers. En informatique, il n'y a jamais de perte de pr√©cision avec les nombres
entiers. Le seul probl√®me vient du nombre de bits √† disposition. Mais je vous
rassure, avec des nombres entier 64 bits on est tranquille pour toutes nos
applications.

Nous avons une notation parfaite pour notre application, reste maintenant la
question des calculs‚Ä¶

### Une solution ce sont les [fractions rationnelles][4]

Revenons √† notre premier cas¬†:

$$\frac{1}{98}\times98=1$$

Nous pouvons donc stocker la division sous la forme d'une cha√Æne de caract√®res
comme `"1/98"`. En cas de nombres n√©gatifs, il suffit d'y ajouter le signe comme
par exemple `"-1/98"`. Vous pouvez aussi envisager de stocker le num√©rateur et
le d√©nominateur dans deux entiers s√©par√©s.

Pour effectuer les calculs, il faudra utiliser une biblioth√®que qui comprenne
les fractions. Pour le Javascript je vous invite √† aller voir [Fraction.js][2].

Voici ce que √ßa peut donner¬†:

```js
import Fraction from "fraction.js";

// 1/98
new Fraction(1).div(98).toString(); // '0.0(102040816326530612244897959183673469387755)'
new Fraction(1).div(98).mul(98).toString(); // '1'
new Fraction("1/98").mul(98).toString(); // '1'
new Fraction(1, 98).mul(98).toString(); // '1'

// 100 * (0.01 + 0.02 + 0.3)
new Fraction(100)
  .mul(
    new Fraction("0.01") //
      .add("0.02")
      .add("0.3")
  )
  .toString(); // '33'
```

Il n'y a plus aucune perte de pr√©cision. C'est pas mal du tout, n√©anmoins je
vous propose d'aller encore plus loin dans la r√©flexion. Toujours en finance, on
ne souhaite pas avoir des chiffres avec plus de 2 d√©cimales √©tant donn√© que
l'unit√© est le centime. Sauf que lors des calculs on ne souhaite pas non plus
perdre des centimes √† cause des arrondis. Il est donc important de figer le
r√©sultat au tout dernier moment. Par exemple lors de la cr√©ation de la facture
(du document) on peut d√©cider d'appliquer l'arrondi au centime.

Prennons l'exemple suivant o√π on verse 10 fois 10/3 CHF.

```js
new Fraction(10).mul("10/3").toString(); // '33.(3)'
new Fraction(10).mul("10/3").toFraction(); // '100/3'
```

Il va falloir demander un arrondi au centime.

```js
new Fraction(10).mul("10/3").round(2).toString(); // '33.33'
```

A ce moment l√†, on a effectivement un montant plausible en centime. Reste que
d√©sormais on a perdu en pr√©cision.

```js
new Fraction(10).mul("10/3").round(2).toFraction(); // '3333/100'
```

### Conserver la valeur exacte tout en ayant l'arrondi

Le r√©sultat avec l'arrondi ne me pla√Æt gu√®re. Il faudrait garder les deux
informations. Il nous faut la fraction exacte, ainsi que la valeur arrondie pour
le r√©sultat final. En ayant la valeur exacte on peut retrouver (ou mieux
comprendre) d'o√π viendrait une diff√©rence d'un centime. Mais mieux encore, et si
on conservait tout l'historique de ce qui s'est pass√© sur le nombre¬†?

Pour cel√†, j'ai imagin√© [un petit projet][8] qui exploite [Fraction.js][2] et
qui permet de conserver l'historique des op√©rations. Voici un exemple¬†:

```js
import Fric from "fric";

let f1 = new Fric("4.2").mul("8.1").div(100);
f1.toFraction(); // '1701/5000'
f1.toString(); // '0.3402'
```

Ici il n'y a pas de diff√©rence directement visible. La suite des op√©rations
semble produire exactement le m√™me genre de r√©sultat qu'en utilisant directement
[Fraction.js][2]. Mais d√©trompez-vous, ici, Fric, conserve l'historique de tout
ce qui se passe sur le nombre. Je peux ainsi lui demander de s√©rialiser l'objet
afin de r√©cup√©rer l'√©quation compl√®te (sous une forme r√©duite).

```js
f1.serialize(); // '21/5:*81/10:/100'
```

Ce qu'on peut lire ici c'est une suite d'op√©rations sous la forme d'une cha√Æne
de caract√®res. On y trouve `21/5` qui correspond √† `4.2`, le `:` sert de
s√©parateur pour les op√©rations. Ensuite on multiplie 4.2 par `81/10`. Pour
terminer on divise ce r√©sultat par 100. Dit autrement, on a calcul√© le 8.1% de
4.2 qui donne bien 0.3402.

Etant donn√© qu'on veut travailler en centime, on peut demander un arrondi de
cette mani√®re¬†:

```js
f1 = f1.round(2);
f1.serialize(); // '21/5:*81/10:/100:o2'
```

L'arrondi n'est rien de plus qu'une op√©ration √† ajouter √† la liste. Le format
s√©rialis√© est donc complet en une seule cha√Æne de caract√®res.

Cette petite biblioth√®que permet bien entendu de faire l'inverse. On peut donner
une version s√©rrialis√©e afin d'y retrouver un object de type `Fric` qui nous
permet alors de continuer d'y effectuer des op√©rations.

```js
let f2 = Fric.deserialize("21/5:*81/10:/100:o2");
f2.toFraction(); // '17/50'
```

## Certains langages proposent le type decimal

Il y a effectivement des langages qui int√®grent un "nouveau" type pour r√©gler la
probl√©matique de la repr√©sentation sous la forme de virgule flottante. Mais
parfois ce n'est que repousser le probl√®me en augmentant simplement la pr√©cision
comme en C#. Et malheureusement il est assez facile de tomber sur des cas
impossible √† repr√©senter correctement m√™me avec ce genre de type.

Voici un exemple en C# et son type [decimal][5] o√π la repr√©sentation est alt√©r√©e
√† cause de la perte de pr√©cision.

```c#
decimal number = 1m / 98m * 98m;
Console.WriteLine(number); // 0.9999999999999999999999999982
```

Il y a √©galement le tr√®s populaire Python qui lui, offre un [type decimal][6]
tr√®s int√©ressant. Ce n'est peut √™tre pas √©trang√© √† sa grande popularit√© dans le
domaine scientifique. Python s'appuie sur la [libmpdec][7] qui m√©riterait
certainement un article approfondi. Je suis aujourd'hui incapable de dire s'il
est possible, avec cette biblioth√®que, de tomber sur des cas impr√©cis.

```python
from decimal import Decimal, getcontext

getcontext().prec = 50
a = Decimal('1')
b = Decimal('98')
result = a / b * b
print(result) # 1.0000000000000000000000000000000000000000000000000
```

## En conclusion

Certainement qu'il faut bien r√©fl√©chir aux types √† utiliser avant de se lancer
dans des calculs financiers ou scientifiques. Le choix d√©pend aussi des
performances. Si les performances ne sont pas indispensables, je pense qu'opter
pour une repr√©sentation fractionnaire et une tr√®s bonne id√©e. Gardez les
virgules flottantes quand les performances sont plus importantes que
l'exactitude math√©matique.

Pour terminer j'esp√®re avoir √©veill√© votre curiosit√© avec ma proposition de
nombre `Fric` qui conservent l'historique des op√©rations. Cette petite
biblioth√®que est (au moment o√π j'√©cris cet article) uniquement un PoC.

[1]: https://fr.wikipedia.org/wiki/Virgule_flottante
[2]: https://github.com/rawify/Fraction.js
[3]:
  https://fr.wikipedia.org/wiki/D%C3%A9veloppement_d%C3%A9cimal_p%C3%A9riodique
[4]: https://fr.wikipedia.org/wiki/Fraction_rationnelle
[5]:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types
[6]: https://docs.python.org/3/library/decimal.html
[7]: https://www.bytereef.org/mpdecimal/index.html
[8]: https://github.com/Skywalker13/fric
[9]: https://fr.wikipedia.org/wiki/Notation_scientifique
