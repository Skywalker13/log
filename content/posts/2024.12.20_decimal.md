---
title: "Les nombres rÃ©els en informatique ~ ğŸ‡«ğŸ‡·"
date: 2024-12-21
tags: [math, c, c#, python, javascript]
description: "Au-delÃ  du rÃ©el"
draft: false
---

- [Mais quâ€™est-ce que le type double](/posts/2024.12.20_decimal/#mais-quest-ce-que-le-type-double)
  - [La virgule flottante](/posts/2024.12.20_decimal/#la-virgule-flottante)
- [Et si on parlait dâ€™argent](/posts/2024.12.20_decimal/#et-si-on-parlait-dargent)
- [Ne plus jamais perdre en prÃ©cision](/posts/2024.12.20_decimal/#ne-plus-jamais-perdre-en-prÃ©cision)
  - [Une solution ce sont les fractions rationnelles](/posts/2024.12.20_decimal/#une-solution-ce-sont-les-fractions-rationnelles4)
  - [Conserver la valeur exacte tout en ayant lâ€™arrondi](/posts/2024.12.20_decimal/#conserver-la-valeur-exacte-tout-en-ayant-larrondi)
- [Certains langages proposent le type decimal](/posts/2024.12.20_decimal/#certains-langages-proposent-le-type-decimal)
- [En conclusion](/posts/2024.12.20_decimal/#en-conclusion)

---

Qui ne s'est jamais confrontÃ© aux problÃ¨mes d'arrondis avec les nombres rÃ©elsÂ ?
Prenons un exemple tout simple. Dans n'importe quel langage de programmation qui
utilise la virgule flottante, l'Ã©quation suivante (si simple au premier abord)
ne donne pas le rÃ©sultat espÃ©rÃ©.

$$\frac{1}{98}\times98=1$$

**Javascript**

```js
console.log(`${(1.0 / 98.0) * 98.0}`); // 0.9999999999999999
```

**Langage C**

```c
#include <stdio.h>
int
main(void)
{
  double number = 1.0;
  number /= 98.0;
  number *= 98.0;
  printf("%.16lf", number); // 0.9999999999999999
  return 0;
}
```

**Langage C#**

```c#
double number = 1.0;
number /= 98.0;
number *= 98.0;
Console.WriteLine(number); // 0.9999999999999999
```

## Mais qu'est-ce que le type double

Tous ces rÃ©sultats seraient trÃ¨s perturbants pour quelqu'un sans connaissance
poussÃ©e en informatique. D'une certaine maniÃ¨re, c'est mÃªme inquiÃ©tant si on
souhaite utiliser un ordinateur comme calculateur en physique. Il est donc trÃ¨s
important de comprendre ce qui se passe en dÃ©tail dans la machinerie et pourquoi
le rÃ©sultat de cette Ã©quation, si triviale, n'est pas exact.

CommenÃ§ons par comprendre ce qui se passe avec la divisionÂ :

$$\frac{1}{98}=0.0\overline{102040816326530612244897959183673469387755}$$

Le rÃ©sultat de cette Ã©quation rend un nombre rÃ©el avec une partie pÃ©riodique de
42 dÃ©cimales. NaÃ¯vement, on pourrait penser que le fait qu'il y ait une pÃ©riode,
implique forcÃ©ment que l'ordinateur ne peut pas contenir un nombre rÃ©el d'une
longueur infinie. Mais cette explication n'est pas complÃ¨te, car ici on
reprÃ©sente les nombres en base 10 et pas en base 2. Prenons un exemple encore
plus simple, avec un nombre sans partie pÃ©riodique et demandons Ã  nos langages
de programmation ce qu'il en est.

$$0.1$$

**Javascript**

```js
console.log(`${0.1}`); // 0.1
```

**Langage C**

```c
#include <stdio.h>
int
main(void)
{
  double number = 0.1;
  printf("%.16lf", number); // 0.1000000000000000
  return 0;
}
```

**Langage C#**

```c#
double number = 0.1;
Console.WriteLine(number); // 0.1
```

> Ouf, Ã§a fonctionneâ€¦

Vous pensez vraiment que tout est bonÂ ? Eh bien il y a un piÃ¨ge. Tous ces
rÃ©sultats sont apparemment corrects, mais pourtant ils apparaissent juste
uniquement parce qu'on a de la chance avec les arrondis. Demandons Ã  nos
langages d'augmenter le nombre de dÃ©cimales visibles.

**Javascript**

```js
console.log(`${(0.1).toFixed(32)}`); // 0.10000000000000000555111512312578
```

**Langage C**

```c
#include <stdio.h>
int
main(void)
{
  double number = 0.1;
  printf("%.32lf", number); // 0.10000000000000000555111512312578
  return 0;
}
```

**Langage C#**

```c#
double number = 0.1;
Console.WriteLine(string.Format("{0:F32}", number)); // 0.10000000000000000555111512312578
```

Comme vous pouvez alors le constater, la vraie valeur 0.1 n'existe pas. Un
ordinateur ne peut pas reprÃ©senter ce chiffre rÃ©el de maniÃ¨re exacte.

### La virgule flottante

Un nombre rÃ©el comme 0.1 doit Ãªtre converti au format binaire avec une [virgule
flottante][1]. C'est une reprÃ©sentation numÃ©rique limitÃ©e par le nombre de bits
disponibles. Par exemple le type double utilise 64 bits.

1. **(S)** Le signe (1 bit) qui dit si le nombre est positif ou nÃ©gatif
2. **(E)** L'exposant (11 bits) qui est un ensemble de bits reprÃ©sentant la
   puissance de base Ã  laquelle la mantisse doit Ãªtre multipliÃ©e
3. **(M)** La mantisse (52 bits) qui est un ensemble de bits qui reprÃ©sente la
   partie significative du nombre

La virgule flottante correspond Ã  la [notation scientifique][9] qu'on utilise
habituellement en mathÃ©matiques.

Un nombre Ã  virgule flottant se calcule ainsiÂ :

$$(-1)^{s}\times1.M\times2^{E-\text{Biais}}$$

Pour 0.1Â :

$$(-1)^{0}\times1.6\times2^{-4}=0.1$$

Pour trouver 1.6 (la mantisse) il faut effectuer une conversion dÃ©cimale-binaire
en utilisant une mÃ©thode assez simple. On multiplie par 2 et on prend la partie
entiÃ¨re du rÃ©sultat, puis on rÃ©pÃ¨te ce processus avec la partie fractionnaire
restante.

- 0.1 \* 2 = 0.2 (partie entiÃ¨re = 0)
- 0.2 \* 2 = 0.4 (partie entiÃ¨re = 0)
- 0.4 \* 2 = 0.8 (partie entiÃ¨re = 0)
- 0.8 \* 2 = 1.6 (partie entiÃ¨re = 1)
- 0.6 \* 2 = 1.2 (partie entiÃ¨re = 1)
- 0.2 \* 2 = 0.4 (partie entiÃ¨re = 0)
- 0.4 \* 2 = 0.8 (partie entiÃ¨re = 0)
- 0.8 \* 2 = 1.6 (partie entiÃ¨re = 1)
- 0.6 \* 2 = 1.2 (partie entiÃ¨re = 1)
- 0.2 \* 2 = 0.4 (partie entiÃ¨re = 0)
- 0.4 \* 2 = 0.8 (partie entiÃ¨re = 0)
- 0.8 \* 2 = 1.6 (partie entiÃ¨re = 1)
- 0.6 \* 2 = 1.2 (partie entiÃ¨re = 1)
- â€¦

Avec 0.1, ce processus ne se termine jamais et produit une sÃ©quence infinie de
bitsÂ : 0.00011001100110011â€¦ 0.1 est alors un nombre avec [une partie dÃ©cimale
pÃ©riodique][3] sous la forme binaire. La mantisse normalisÃ©e va ressembler Ã 
1.100110011001100110011â€¦ (on dÃ©cale simplement la virgule comme on le ferait en
base 10 avec la [notation scientifique][9])

Il est alors impossible d'avoir une reprÃ©sentation exacte en base 2 car nous
avons un nombre limitÃ© de bits disponibles. Un nombre qui nous semble trÃ¨s
simple en base 10, ne l'est pas forcÃ©ment en base 2.

## Et si on parlait d'argent

La finance est un domaine sujet aux arrondis et donc Ã  de la perte de prÃ©cision.
Le problÃ¨me vient simplement du centime qui reprÃ©sente l'unitÃ© de la monnaie.
Que faire quand on doit distribuer de l'argent alors qu'il y a une perte de
prÃ©cisionÂ ? Prenons un exemple tout simple. J'ai 3 amis Ã  qui je dois partager
un billet de 10 CHF. Voici quelques solutions Ã  cette problÃ©matique.

1. Je dÃ©coupe le billet en trois parts Ã©gales avec une paire de ciseaux.  
   Je doute que mes amis soient trÃ¨s contents mais avec cette technique, je peux
   avoir une trÃ¨s grande prÃ©cision.
2. Je donne 3.33 CHF Ã  chacun de mes amis, et je garde 1 centime pour moi.
3. Je donne 3.33 CHF Ã  deux de mes amis, et Ã  celui que je prÃ©fÃ¨re je lui donne
   3.34 CHF.

Ã€ part la premiÃ¨re solution, les deux autres sont satisfaisantes dans ce
contexte car je peux produire des factures Ã  ce moment-lÃ  pour figer les
transactions; mais compliquons l'exemple.

Pendant 10 mois, il sera comptabilisÃ© 10/3 CHF pour chacun d'eux. AprÃ¨s 10 mois,
ils recevront l'argent.

$$10\times\frac{10}{3} = 33.\overline{3}$$

Il n'y a pas de facture intermÃ©diaire. En effet, mes amis vont recevoir
uniquement le montant final.

Chaque mois, il y a un montant de 10/3 CHF qui est ajoutÃ© Ã  chaque compte. Si je
stocke le rÃ©sultat de l'opÃ©ration j'ai forcÃ© un arrondi. C'est un problÃ¨me
habituel en finance. On stocke les rÃ©sultats et pas les Ã©quations pour y
arriver.

> Peut-Ãªtre avez-vous quelques souvenirs de vos cours de mathÃ©matiques. Combien
> de fois le professeur vous a dit que les rÃ©sultats ne l'intÃ©ressent pas, c'est
> uniquement l'Ã©quation qui importe.

Admettons que je travaille de maniÃ¨re traditionnelle. Mon systÃ¨me stocke les
rÃ©sultats au centime et donc je partage le billet de 10 CHF en parts de 3.33
CHF.

|       | 1Â Jan. | 1Â FÃ©v. | 1Â Mar. | 1Â Avr. | 1Â Mai | 1Â Jun. | 1Â Jui. | 1Â AoÃ». | 1Â Sep. | 1Â Oct. | Perte |
| ----- | -----: | -----: | -----: | -----: | ----: | -----: | -----: | -----: | -----: | -----: | ----: |
| AmiÂ 1 |   3.33 |   6.66 |   9.99 |  13.32 | 16.65 |  19.98 |  23.31 |  26.64 |  29.97 |  33.30 |  0.03 |
| AmiÂ 2 |   3.33 |   6.66 |   9.99 |  13.32 | 16.65 |  19.98 |  23.31 |  26.64 |  29.97 |  33.30 |  0.03 |
| AmiÂ 3 |   3.33 |   6.66 |   9.99 |  13.32 | 16.65 |  19.98 |  23.31 |  26.64 |  29.97 |  33.30 |  0.03 |
|       |        |        |        |        |       |        |        |        |        |        |       |
| Total |   9.99 |  19.98 |  29.97 |  39.96 | 49.95 |  59.94 |  69.93 |  79.92 |  89.91 |  99.90 |  0.09 |

Le 1er octobre, il y a 10 centimes qui n'ont jamais Ã©tÃ© distribuÃ©s (chaque mois
il y a un centime qui "saute" Ã  cause de l'arrondi). Il faudrait au moins
distribuer encore 9 centimes (car 10 n'est pas divisible par 3). Le dernier
centime, je peux le garder dans ma poche.

Et si on avait simplement travaillÃ© en double sans forcer d'arrondi au centimeÂ ?

Dans ce cas, on aurait trouvÃ© quelque chose comme 33.3333333â€¦ car en double on a
une bonne prÃ©cision. Avec l'arrondi final, on a donc bien rÃ©cupÃ©rÃ© les 3
centimes manquants. C'est mieux mais Ã§a ne suffit pas. On ne fait que repousser
le problÃ¨me en augmentant la prÃ©cision.

Prenons par exemple cette Ã©quationÂ :

$$100\times(0.01 + 0.02 + 0.3) = 33$$

On manipule ici 100 fois 33 centimes. Cela n'a rien d'extraordinaire, pourtant
mÃªme en double on perd trop en prÃ©cision et notre calcul est faussÃ© Ã  cause des
additions.

`100 * (0.01 + 0.02 + 0.3) = 32.99999999999999`

Bien entendu, avec un arrondi on y arrive, mais arrondir ne permet pas toujours
de s'en sortir quand on cumule beaucoup d'opÃ©rations. On peut finir par avoir
une erreur d'un centime presque impossible Ã  expliquer. Alors pourquoi continuer
Ã  travailler avec des nombres Ã  virgule flottanteÂ ?

## Ne plus jamais perdre en prÃ©cision

Maintenant que vous savez qu'il ne faut pas se fier aveuglÃ©ment aux nombres Ã 
virgule flottante, comment pouvons-nous rÃ©gler cette question une bonne fois
pour toutesÂ ? Un moyen simple de ne jamais perdre en prÃ©cision est de tout
simplement stocker vos nombres sous la forme de chaÃ®nes de caractÃ¨res. Revenons
Ã  notre exemple avec 0.1. Si je stocke `"0.1"` au lieu du double 0.1, je donne
une garantie de prÃ©cision.

Que dire de notre tout premier exemple avec la division de 1 par 98Â ? Nous
pouvons aussi tenter une reprÃ©sentation sous forme de chaÃ®ne de caractÃ¨res. Par
exemple `"0.0(102040816326530612244897959183673469387755)"`. Cette
reprÃ©sentation nous donne exactement le rÃ©sultat de la division sans perte de
prÃ©cision car la partie pÃ©riodique est reprÃ©sentÃ©e par les parenthÃ¨ses.

Je ne sais pas pour vous, mais pour moi ce n'est pas complÃ¨tement satisfaisant.
Bien que les nombres soient exacts, c'est surtout le second cas qui me dÃ©range
un peu. Et si on utilisait des reprÃ©sentations fractionnairesÂ ? Pour 0.1, on
pourrait l'Ã©crire aussi sous la forme d'une chaÃ®ne de caractÃ¨res mais en tant
que fraction `"1/10"`. Avec le second cas, on aurait alors simplement `"1/98"`.

Je pense que vous Ãªtes d'accord avec moi. Utiliser `"1/98"` au lieu de
`"0.0(102040816326530612244897959183673469387755)"` est bien plus pratique, et
en plus Ã§a prend beaucoup moins de place. Le second avantage, c'est que dans le
cas de nos fractions, si nous considÃ©rons supporter uniquement des [nombres
rationnels][4], alors le numÃ©rateur et le dÃ©nominateur seront toujours des
entiers. En informatique, il n'y a jamais de perte de prÃ©cision avec les nombres
entiers. Le seul problÃ¨me vient du nombre de bits Ã  disposition. Mais je vous
rassure, avec des nombres entiers de 64 bits, on est tranquille pour toutes nos
applications.

Nous avons une notation parfaite pour notre application, reste maintenant la
question des calculsâ€¦

### Une solutionÂ : ce sont les [fractions rationnelles][4]

Revenons Ã  notre premier casÂ :

$$\frac{1}{98}\times98=1$$

Nous pouvons donc stocker la division sous la forme d'une chaÃ®ne de caractÃ¨res
comme `"1/98"`. En cas de nombres nÃ©gatifs, il suffit d'y ajouter le signe comme
par exemple `"-1/98"`. Vous pouvez aussi envisager de stocker le numÃ©rateur et
le dÃ©nominateur dans deux entiers sÃ©parÃ©s.

Pour effectuer les calculs, il faudra utiliser une bibliothÃ¨que qui comprenne
les fractions. Pour le Javascript, je vous invite Ã  aller voir [Fraction.js][2].

Voici ce que cela peut donnerÂ :

```js
import Fraction from "fraction.js";

// 1/98
new Fraction(1).div(98).toString(); // '0.0(102040816326530612244897959183673469387755)'
new Fraction(1).div(98).mul(98).toString(); // '1'
new Fraction("1/98").mul(98).toString(); // '1'
new Fraction(1, 98).mul(98).toString(); // '1'

// 100 * (0.01 + 0.02 + 0.3)
new Fraction(100)
  .mul(
    new Fraction("0.01") //
      .add("0.02")
      .add("0.3")
  )
  .toString(); // '33'
```

Il n'y a plus aucune perte de prÃ©cision. C'est pas mal du tout, nÃ©anmoins je
vous propose d'aller encore plus loin dans la rÃ©flexion. Toujours en finance, on
ne souhaite pas avoir des chiffres avec plus de 2 dÃ©cimales, Ã©tant donnÃ© que
l'unitÃ© est le centime. Sauf que lors des calculs, on ne souhaite pas non plus
perdre des centimes Ã  cause des arrondis. Il est donc important de figer le
rÃ©sultat au tout dernier moment. Par exemple, lors de la crÃ©ation de la facture
(du document), on peut dÃ©cider d'appliquer l'arrondi au centime.

Prenons l'exemple suivant oÃ¹ on verse 10 fois 10/3 CHF.

```js
new Fraction(10).mul("10/3").toString(); // '33.(3)'
new Fraction(10).mul("10/3").toFraction(); // '100/3'
```

Il va falloir demander un arrondi au centime.

```js
new Fraction(10).mul("10/3").round(2).toString(); // '33.33'
```

Ã€ ce moment-lÃ , on a effectivement un montant plausible en centimes. Reste que
dÃ©sormais, on a perdu en prÃ©cision.

```js
new Fraction(10).mul("10/3").round(2).toFraction(); // '3333/100'
```

### Conserver la valeur exacte tout en ayant l'arrondi

Le rÃ©sultat avec l'arrondi ne me plaÃ®t guÃ¨re. Il faudrait garder les deux
informations. Il nous faut la fraction exacte, ainsi que la valeur arrondie pour
le rÃ©sultat final. En ayant la valeur exacte, on peut retrouver (ou mieux
comprendre) d'oÃ¹ viendrait une diffÃ©rence d'un centime. Mais mieux encore, et si
on conservait tout l'historique de ce qui s'est passÃ© sur le nombreÂ ?

Pour cela, j'ai imaginÃ© [un petit projet][8] qui exploite [Fraction.js][2] et
qui permet de conserver l'historique des opÃ©rations. Voici un exempleÂ :

```js
import Fric from "fric";

let f1 = new Fric("4.2").mul("8.1").div(100);
f1.toFraction(); // '1701/5000'
f1.toString(); // '0.3402'
```

Ici, il n'y a pas de diffÃ©rence directement visible. La suite des opÃ©rations
semble produire exactement le mÃªme genre de rÃ©sultat qu'en utilisant directement
[Fraction.js][2]. Mais dÃ©trompez-vous, ici, Fric conserve l'historique de tout
ce qui se passe sur le nombre. Je peux ainsi lui demander de sÃ©rialiser l'objet
afin de rÃ©cupÃ©rer l'Ã©quation complÃ¨te (sous une forme rÃ©duite).

```js
f1.serialize(); // '21/5:*81/10:/100'
```

Ce qu'on peut lire ici, c'est une suite d'opÃ©rations sous la forme d'une chaÃ®ne
de caractÃ¨res. On y trouve `21/5` qui correspond Ã  `4.2`. Le `:` sert de
sÃ©parateur pour les opÃ©rations. Ensuite, on multiplie 4.2 par `81/10`. Pour
terminer, on divise ce rÃ©sultat par 100. Dit autrement, on a calculÃ© les 8.1% de
4.2, ce qui donne bien 0.3402.

Ã‰tant donnÃ© qu'on veut travailler en centimes, on peut demander un arrondi de
cette maniÃ¨reÂ :

```js
f1 = f1.round(2);
f1.serialize(); // '21/5:*81/10:/100:o2'
```

L'arrondi n'est rien de plus qu'une opÃ©ration Ã  ajouter Ã  la liste. Le format
sÃ©rialisÃ© est donc complet en une seule chaÃ®ne de caractÃ¨res.

Cette petite bibliothÃ¨que permet bien entendu de faire l'inverse. On peut donner
une version sÃ©rialisÃ©e afin d'y retrouver un objet de type `Fric` qui nous
permet alors de continuer d'y effectuer des opÃ©rations.

```js
let f2 = Fric.deserialize("21/5:*81/10:/100:o2");
f2.toFraction(); // '17/50'
```

## Certains langages proposent le type decimal

Il y a effectivement des langages qui intÃ¨grent un "nouveau" type pour rÃ©gler la
problÃ©matique de la reprÃ©sentation sous la forme de virgule flottante. Mais
parfois, ce n'est que repousser le problÃ¨me en augmentant simplement la
prÃ©cision, comme en C#. Et malheureusement, il est assez facile de tomber sur
des cas impossibles Ã  reprÃ©senter correctement mÃªme avec ce genre de type.

Voici un exemple en C# et son type [decimal][5] oÃ¹ la reprÃ©sentation est altÃ©rÃ©e
Ã  cause de la perte de prÃ©cision.

```c#
decimal number = 1m / 98m * 98m;
Console.WriteLine(number); // 0.9999999999999999999999999982
Console.WriteLine(number == 1); // False
```

Il y a Ã©galement le trÃ¨s populaire Python qui, lui, offre un [type decimal][6]
trÃ¨s intÃ©ressant. Ce n'est peut-Ãªtre pas Ã©tranger Ã  sa grande popularitÃ© dans le
domaine scientifique. Python s'appuie sur la [libmpdec][7] qui mÃ©riterait
certainement un article approfondi. Je suis aujourd'hui incapable de dire s'il
est possible, avec cette bibliothÃ¨que, de tomber sur des cas imprÃ©cis.

```python
from decimal import Decimal, getcontext

getcontext().prec = 50
a = Decimal('1')
b = Decimal('98')
result = a / b * b
print(result) # 1.0000000000000000000000000000000000000000000000000
print(result == 1) # True
```

## En conclusion

Il faut certainement bien rÃ©flÃ©chir aux types Ã  utiliser avant de se lancer dans
des calculs financiers ou scientifiques. Le choix dÃ©pend aussi des performances.
Si les performances ne sont pas indispensables, je pense qu'opter pour une
reprÃ©sentation fractionnaire est une trÃ¨s bonne idÃ©e. Gardez les virgules
flottantes quand les performances sont plus importantes que l'exactitude
mathÃ©matique.

Pour terminer, j'espÃ¨re avoir Ã©veillÃ© votre curiositÃ© avec ma proposition de
nombre `Fric` qui conserve l'historique des opÃ©rations. Cette [petite
bibliothÃ¨que][8] est (au moment oÃ¹ j'Ã©cris cet article) uniquement un [PoC][10].

[1]: https://fr.wikipedia.org/wiki/Virgule_flottante
[2]: https://github.com/rawify/Fraction.js
[3]:
  https://fr.wikipedia.org/wiki/D%C3%A9veloppement_d%C3%A9cimal_p%C3%A9riodique
[4]: https://fr.wikipedia.org/wiki/Fraction_rationnelle
[5]:
  https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types
[6]: https://docs.python.org/3/library/decimal.html
[7]: https://www.bytereef.org/mpdecimal/index.html
[8]: https://github.com/Skywalker13/fric
[9]: https://fr.wikipedia.org/wiki/Notation_scientifique
[10]: https://fr.wikipedia.org/wiki/Preuve_de_concept
