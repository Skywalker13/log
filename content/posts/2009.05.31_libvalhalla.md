---
title: "Les nouvelles fonctions de s√©lection de libvalhalla ~ üá´üá∑"
date: 2009-05-31
tags: [geexbox, libvalhalla]
description: "Les nouvelles fonctions de s√©lection"
draft: true
---

Hello,

depuis peu, les modifications √©voqu√©es dans le [billet pr√©c√©dent][1] ont √©t√©
r√©alis√©es. L‚ÄôAPI a √©t√© modifi√©e pour toutes les fonctions qui permettent
d‚Äôeffectuer des s√©lections sur la base de donn√©e. Ce blog √©tant aussi en quelque
sorte un carnet de laboratoire, je vais donc y expliquer le fonctionnement de
ces fonctions ainsi que la mani√®re de les utiliser. A terme, ces informations
figureront directement dans la documentation (en anglais) de libvalhalla. Il est
judicieux de consulter la documentation Doxygen d√©j√† pr√©sente dans l‚Äôen-t√™te
public (valhalla.h) qui peut √™tre g√©n√©r√© via un param√®tre du script ‚Äúconfigure‚Äù.

> Cet article est long et tr√®s sp√©cifique √† libvalhalla du c√¥t√© d√©veloppeur
> uniquement. Si vous √™tes un simple utilisateur d‚ÄôEnna, vous ne verrez pas
> vraiment de diff√©rence par rapport √† avant car les modifications sont
> majoritairement internes.

Il y a trois fonctions publiques et chacune est compl√©mentaire aux autres.

```c
int valhalla_db_metalist_get (
  valhalla_t *handle,
  valhalla_db_item_t *search,
  valhalla_db_restrict_t *restriction,
  int (*result_cb) (void *data,
                    valhalla_db_metares_t *res),
  void *data);

int valhalla_db_filelist_get (
  valhalla_t *handle,
  valhalla_file_type_t filetype,
  valhalla_db_restrict_t *restriction,
  int (*result_cb) (void *data,
                    valhalla_db_fileres_t *res),
  void *data);

int valhalla_db_file_get (
  valhalla_t *handle,
  int64_t id, const char *path,
  valhalla_db_restrict_t *restriction,
  valhalla_db_filemeta_t **res);
```

![bird](/img/bird1.png)

## valhalla_db_metalist_get

### Utilisation simple

Elle permet de r√©cup√©rer une liste de metadata. Cela veut dire, par exemple une
liste d‚Äôalbums, d‚Äôauteurs, d‚Äôartistes, de genres; peu importe le nom, vous
pouvez r√©cup√©rer n‚Äôimporte quelle liste. Le r√©sultat se pr√©sente toujours sous
la forme du nom du champ (comme ‚Äúauthor‚Äù) avec une valeur et un groupe. Sous la
forme d‚Äôun tableau, cela donnerait quelque chose comme :

| meta id | meta name | data id | data value      | group    |
| ------- | --------- | ------- | --------------- | -------- |
| 2       | author    | 1665    | Dido            | ENTITIES |
| 2       | author    | 456     | Ennio Morricone | ENTITIES |
| 2       | author    | 1257    | John Williams   | ENTITIES |
| 2       | author    | 1224    | Linkin Park     | ENTITIES |

Dans cet exemple, uniquement les auteurs sont pr√©sents, mais il est √©galement
possible de demander une liste de metadata selon un groupe et non selon un nom
de meta ou un id. Vous pouvez typiquement demander la liste de toutes les
metadata qui appartiennent au group `ENTITIES`. De ce fait, vous trouverez la
liste de tous les auteurs, artistes, compositeurs, studios, etc,‚Ä¶

Sans rentrer encore dans les d√©tails du code, une telle liste se r√©cup√®re de
cette mani√®re :

```c
valhalla_db_item_t s = VALHALLA_DB_SEARCH_TEXT ("author", ENTITIES);
valhalla_db_metalist_get (handle, &s, NULL, callback, NULL);
```

Et sans expliquer en d√©tail la fonction, l‚Äôargument ‚Äúhandle‚Äù correspond au
pointeur sur votre instance de valhalla, ‚Äús‚Äù (pour search) d√©fini ce que vous
cherchez, le troisi√®me argument permet de sp√©cifier des restrictions (qui sont
expliqu√©es dans le chapitre suivant), le callback est la fonction dans laquelle
chaque ligne du r√©sultat est envoy√©e et le dernier argument est un pointeur void
qui peut √™tre r√©cup√©r√© dans le callback.

Les macros `VALHALLA_DB_SEARCH_XXX` sont pr√©sentes pour simplifier l‚Äôutilisation
de libvalhalla. Elles ne sont pas indispensables. En r√©alit√©, elle ne font
qu‚Äôattribuer les valeurs au bon endroit dans la structure `valhalla_db_item_t`.
Actuellement il existe trois macros diff√©rentes:

- `VALHALLA_DB_SEARCH_ID(meta_id, group)`
- `VALHALLA_DB_SEARCH_TEXT(meta_text, group)`
- `VALHALLA_DB_SEARCH_GRP(group)`

Vous pouvez donc chercher une liste de meta en fonction de l‚Äôid, du texte, ou
alors vous pouvez r√©cup√©rer plusieurs noms de metadata diff√©rents dans le cas
d‚Äôune recherche selon un groupe.

### Utilisation √©tendue

R√©cup√©rer une liste comme expliqu√© dans le chapitre pr√©c√©dent est la
fonctionnalit√© la plus simple offerte par cette fonction. Il va de soit qu‚Äôil
faut pouvoir donner quelques restrictions sur la liste retourn√©e. Il est courant
de ne pas vouloir une liste compl√®te. Un exemple parlant concerne la metadata
‚Äúalbum‚Äù. Il est int√©ressant de pouvoir r√©cup√©rer tous les albums d‚Äôun auteur en
particulier. Et c‚Äôest ici qu‚Äôinterviennent les restrictions. Elles permettent
d‚Äôinclure ou d‚Äôexclure certains r√©sultats. D‚Äôun point de vue SQL, se sont des
sous-requ√™tes qui limitent les r√©sultats √† leur ensemble, ou alors √† tous les
r√©sultats diff√©rents de leur ensemble.

Voici un premier exemple. Vous voulez tous les albums de Dido :

```c
valhalla_db_item_t s = VALHALLA_DB_SEARCH_TEXT ("album", TITLES);
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (IN, "author", "Dido");
valhalla_db_metalist_get (handle, &s, &r1, callback, NULL);
```

Le r√©sultat sera un tableau de la m√™me forme que vue pr√©c√©demment, mais qui
contiendra uniquement les albums de Dido.

| meta id | meta name | data id | data value     | group  |
| ------- | --------- | ------- | -------------- | ------ |
| 3       | album     | 1666    | Life For Rent  | TITLES |
| 3       | album     | 1669    | No Angel       | TITLES |
| 3       | album     | 1725    | Safe Trip Home | TITLES |

Cette requ√™te est d√©j√† bien plus sophistiqu√©e, car vous pouvez imaginer de
donner ce genre de restriction pour n‚Äôimporte quel metadata. Un autre exemple,
vous pourriez lister tous les albums d‚Äôune certaine ann√©e. Il n‚Äôy a aucune
limite sur les choix des restrictions. Mais ceci n‚Äôest pas suffisant, et il y a
donc des possibilit√©s un peu plus complexes afin d‚Äôavoir des r√©sultats plus
sp√©cifiques.

Tout d‚Äôabord, dans l‚Äôexemple pr√©c√©dent, la macro `VALHALLA_DB_RESTRICT` est
utilis√©e avec un premier argument ‚ÄúIN‚Äù. Il est possible d‚Äôinverser la logique en
y inscrivant ‚ÄúNOTIN‚Äù √† la place. Le r√©sultat deviendrait alors la liste de tous
les albums qui existent dans la base de donn√©e, sauf ceux de Dido.

### Utilisation avanc√©e

L‚Äôutilisation √©tendue permet d√©j√† d‚Äôeffectuer de nombreuse recherches
int√©ressantes. N√©anmoins pour les cas les plus pr√©cis, elle ne suffit pas. Il
est n√©cessaire parfois de cumuler les restrictions pour affiner le r√©sultats, ou
tout simplement, pour avoir des r√©sultats un peu plus exotiques. Ainsi les
restrictions sont des listes cha√Æn√©es, et il est possible de les lier tr√®s
facilement. Commen√ßons par un exemple, nous d√©sirons la liste de tous les albums
de Dido qui ne sont pas de 2003.

```c
valhalla_db_item_t s = VALHALLA_DB_SEARCH_TEXT ("album", TITLES);
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (IN, "author", "Dido");
valhalla_db_restrict_t r2 = VALHALLA_DB_RESTRICT_STR (NOTIN, "year", "2003");
VALHALLA_DB_RESTRICT_LINK (r2, r1);
valhalla_db_metalist_get (handle, &s, &r1, callback, NULL);
```

Une nouvelle macro est donc introduite. Elle permet de lier tr√®s simplement les
restrictions ensemble. La macro doit √™tre comprise de cette mani√®re. ‚Äúlink from
r2 to r1‚Äù, soit lier de r2 √† r1. Ainsi c‚Äôest r1 qui doit √™tre sp√©cifi√© dans la
fonction `valhalla_db_metalist_get()`. Il n‚Äôy a aucune limite sur le nombre de
liens possibles (mise √† part qu‚Äôune requ√™te ne doit pas d√©passer 4096
caract√®res), n√©anmoins il ne faut pas tenter de lier toutes les restrictions sur
la m√™me car seul le dernier lien sera consid√©r√©. Avec trois restrictions, la
bonne mani√®re de proc√©der est donc :

```c
valhalla_db_item_t s = VALHALLA_DB_SEARCH_TEXT ("album", TITLES);
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (IN, "author", "Linkin Park");
valhalla_db_restrict_t r2 = VALHALLA_DB_RESTRICT_STR (NOTIN, "year", "2003");
valhalla_db_restrict_t r3 = VALHALLA_DB_RESTRICT_STR (NOTIN, "genre", "Alternative");
VALHALLA_DB_RESTRICT_LINK (r3, r2);
VALHALLA_DB_RESTRICT_LINK (r2, r1);
valhalla_db_metalist_get (handle, &s, &r1, callback, NULL);
```

Ici, la liste concernera donc tous les albums de Linkin Park, qui ne sont pas de
2003 et qui ne sont pas du rock/metal alternatif. Okay, la liste ne risque pas
d‚Äô√™tre bien longue avec cet exemple :-P, mais ce qui compte c‚Äôest de montrer le
principe. Les restrictions sont li√©es de la mani√®re suivante: de r3 √† r2 et de
r2 √† r1. En code √ßa donnerait donc :

```c
r2.next = &r3;
r1.next = &r2;
```

Le code ci-dessus peut tr√®s bien remplacer la macro si vous pr√©f√©rez.

Il y a encore une macro que je n‚Äôai pas vraiment pr√©sent√©. Pour l‚Äôargument de
recherche de la fonction, il est possible d‚Äôindiquer uniquement un groupe (comme
je l‚Äôai mentionn√© plus haut dans ce billet). Si le groupe est mit √† NIL, il y
aura toutes les metadata qui seront list√©es, autrement il n‚Äôy aura que les
metadata li√©es au groupe.

Un dernier exemple qui retourne absolument toutes les metadata li√©es √† Dido pour
son album Life For Rent.

```c
valhalla_db_item_t s = VALHALLA_DB_SEARCH_GRP (NIL);
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (IN, "author", "Dido");
valhalla_db_restrict_t r2 = VALHALLA_DB_RESTRICT_STR (IN, "album", "Life For Rent");
VALHALLA_DB_RESTRICT_LINK (r2, r1);
valhalla_db_metalist_get (handle, &s, &r1, callback, NULL);
```

---

| meta id | meta name | data id | data value                | group          |
| ------- | --------- | ------- | ------------------------- | -------------- |
| 6       | track     | 19      | 1                         | ORGANIZATIONAL |
| 6       | track     | 225     | 10                        | ORGANIZATIONAL |
| 6       | track     | 229     | 11                        | ORGANIZATIONAL |
| 6       | track     | 242     | 12                        | ORGANIZATIONAL |
| 6       | track     | 92      | 2                         | ORGANIZATIONAL |
| 5       | year      | 50      | 2003                      | TEMPORAL       |
| 6       | track     | 202     | 3                         | ORGANIZATIONAL |
| 6       | track     | 101     | 4                         | ORGANIZATIONAL |
| 6       | track     | 223     | 5                         | ORGANIZATIONAL |
| 6       | track     | 96      | 6                         | ORGANIZATIONAL |
| 6       | track     | 231     | 7                         | ORGANIZATIONAL |
| 6       | track     | 196     | 8                         | ORGANIZATIONAL |
| 6       | track     | 187     | 9                         | ORGANIZATIONAL |
| 1       | title     | 1673    | BonusTrack                | TITLES         |
| 2       | author    | 1665    | Dido                      | ENTITIES       |
| 1       | title     | 1668    | Do You Have A Little Time | TITLES         |
| 1       | title     | 1672    | Dont Leave Home           | TITLES         |
| 1       | title     | 1666    | Life For Rent             | TITLES         |
| 3       | album     | 1666    | Life For Rent             | TITLES         |
| 1       | title     | 1678    | Marys In India            | TITLES         |
| 4       | genre     | 104     | Pop                       | CLASSIFICATION |
| 1       | title     | 1670    | Sand In My Shoes          | TITLES         |
| 1       | title     | 1669    | See The Sun               | TITLES         |
| 1       | title     | 1674    | See You When Youre 40     | TITLES         |
| 1       | title     | 1675    | Stoned                    | TITLES         |
| 1       | title     | 1671    | This Land Is Mine         | TITLES         |
| 1       | title     | 1664    | White Flag                | TITLES         |
| 1       | title     | 1667    | Who Makes You Feel        | TITLES         |

### Et d‚Äôun point de vue SQL

La requ√™te SQL qui effectue les s√©lections est cr√©√©e en fonction des arguments
de la fonction. Elle se construit comme des Lego qui s‚Äôimbriquent les uns dans
les autres. D‚Äôune mani√®re g√©n√©ral, sa forme est:

```sql
SELECT meta.meta_id, data.data_id, meta.meta_name, data.data_value
FROM (
 data INNER JOIN assoc_file_metadata AS assoc
 ON data.data_id = assoc.data_id
) INNER JOIN meta
ON assoc.meta_id = meta.meta_id
-- Les conditions sont optionnelles
WHERE
  -- Une sous-requ√™te appara√Æt par le biais des restrictions.
  -- Il y a autant de sous-requ√™tes que de restrictions du type IN, NOT IN.
  assoc.file_id <IN|NOT IN> (
    SELECT assoc.file_id
    FROM (
      data INNER JOIN assoc_file_metadata AS assoc
      ON data.data_id = assoc.data_id
    ) INNER JOIN meta
    ON assoc.meta_id = meta.meta_id
    -- A choix, il peut y avoir un ID ou du texte.
    WHERE meta.<meta_id|meta_name> = <ID|"TEXT"> AND data.<data_id|data_value> = <ID|"TEXT">
  )
  -- L'argument search indique quel meta et/ou quel groupe doit √™tre list√©
  AND meta.<meta_id|meta_name> = <ID|"TEXT">
  AND assoc._grp_id = <ID>
GROUP BY assoc.meta_id, assoc.data_id
ORDER BY data.data_value;
```

Sa longueur varie fortement selon le nombre de conditions. Il est possible de
visualiser les requ√™tes g√©n√©r√©es par Valhalla en utilisant la verbosit√© maximale
de la biblioth√®que.

![](/img/bird1.png)

## valhalla_db_filelist_get

### Utilisation simple

La r√©cup√©ration d‚Äôune liste de fichiers ressemble √† celle pour les metadata. La
diff√©rence vient principalement du deuxi√®me argument qui fait r√©f√©rence au type
de fichier (audio, video, etc, ‚Ä¶). Ce qui limite ensuite la liste se sont les
restrictions. L‚Äôutilisation √©tant exactement la m√™me, je vais aller droit au but
avec des exemples.

Pour lister la totalit√© des fichiers r√©f√©renc√©s dans la base de donn√©e, rien de
plus simple :

```c
valhalla_db_filelist_get (handle, VALHALLA_FILE_TYPE_NULL, NULL, callback, NULL);
```

Le fait d‚Äôindiquer un type de fichier NULL, permet d‚Äôignorer le type. Le
r√©sultat de cette requ√™te correspond √† un tableau de ce genre qui contiendrait
la totalit√© de l‚Äôarborescence :

| id  | path                                                    | filetype |
| --- | ------------------------------------------------------- | -------- |
| ‚Ä¶   | ‚Ä¶                                                       | ‚Ä¶        |
| 101 | /home/foo/bar/dido/life_for_rent/sand_in_my_shoes.m4a   | AUDIO    |
| 102 | /home/foo/bar/dido/life_for_rent/white_flag.m4a         | AUDIO    |
| 103 | /home/foo/bar/dido/life_for_rent/who_makes_you_feel.m4a | AUDIO    |
| ‚Ä¶   | ‚Ä¶                                                       | ‚Ä¶        |

### Avec les restrictions

Il est ensuite facile de faire du tri avec les restrictions, de la m√™me mani√®re
que pour la fonction pr√©c√©dente. Par exemple, pour lister tous les fichiers
d‚ÄôEnnio Morricone qui ne sont r√©f√©renc√©s dans aucun album.

```c
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (IN, "author", "Ennio Morricone");
valhalla_db_restrict_t r2 = VALHALLA_DB_RESTRICT_STR (NOTIN, "album", NULL);
VALHALLA_DB_RESTRICT_LINK (r2, r1);
valhalla_db_filelist_get (handle, VALHALLA_FILE_TYPE_NULL, &r1, callback, NULL);
```

Et ci-dessous, un autre exemple qui correspond √† la cat√©gorie ‚ÄúNon Class√©‚Äù dans
Enna. Tous les fichiers qui ne sont ni dans un album, ni li√© √† un author et dont
le genre est ind√©fini.

```c
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (NOTIN, "album", NULL);
valhalla_db_restrict_t r2 = VALHALLA_DB_RESTRICT_STR (NOTIN, "author", NULL);
valhalla_db_restrict_t r3 = VALHALLA_DB_RESTRICT_STR (NOTIN, "genre", NULL);
VALHALLA_DB_RESTRICT_LINK (r3, r2);
VALHALLA_DB_RESTRICT_LINK (r2, r1);
valhalla_db_filelist_get (handle, VALHALLA_FILE_TYPE_NULL, &r1, callback, NULL);
```

Facile, non?

> A noter que ce n‚Äôest pas encore totalement optimal, car le groupe ne peut pas
> √™tre donn√© avec les restrictions. Ainsi n‚Äôimporte quel metadata de n‚Äôimporte
> quel groupe est consid√©r√©e dans l‚Äôinclusion comme l‚Äôexclusion.

### Et d‚Äôun point de vue SQL

La aussi, la requ√™te ressemble beaucoup √† la pr√©c√©dente avec des diff√©rences au
niveau de ce qui est s√©lectionn√© et dans quelle table.

```sql
SELECT file_id, file_path, _type_id
FROM file AS assoc
-- Les conditions sont optionnelles
WHERE
  -- Une sous-requ√™te appara√Æt par le biais des restrictions.
  -- Il y a autant de sous-requ√™tes que de restrictions du type IN, NOT IN.
  assoc.file_id <IN|NOT IN> (
    SELECT assoc.file_id
    FROM (
      data INNER JOIN assoc_file_metadata AS assoc
      ON data.data_id = assoc.data_id
    ) INNER JOIN meta
    ON assoc.meta_id = meta.meta_id
    -- A choix, il peut y avoir un ID ou du texte.
    WHERE meta.<meta_id|meta_name> = <ID|"TEXT"> AND data.<data_id|data_value> = <ID|"TEXT">
  )
  -- Le type n'est pas inscrit dans la requ√™te si la valeur est NULL.
  AND _type_id = <ID>
ORDER BY file_id;
```

Si dans la clause `FROM`, la table ‚Äúfile‚Äù cr√©er un alias ‚Äúassoc‚Äù, c‚Äôest
uniquement pour une question de factorisation dans le code par rapport √† la
sous-requ√™te.

![](/img/bird1.png)

## valhalla_db_file_get

Maintenant que l‚Äôon a vu comment r√©cup√©rer des listes de metadata ainsi que des
listes de fichiers, il est important de pouvoir aussi r√©cup√©rer des metadata en
fonction d‚Äôun fichier sp√©cifique. Cette possibilit√© n‚Äôexistait pas avec l‚Äôancien
mod√®le car les fichiers √©taient toujours retourn√©s dans une liste. Ici il est
question d‚Äôun seul fichier √† la fois. Il faut √©galement √™tre conscient que cette
fonction est li√©e uniquement √† la base de donn√©e, si un fichier non r√©f√©renc√©
dans la base mais existant quelque part est donn√© en argument, aucun r√©sultat ne
sera retourn√© (cette possibilit√© existera quand j‚Äôimpl√©menterai le ‚Äúscan
on-demand‚Äù).

Les arguments sont donc l‚Äôid du fichier, le chemin du fichier, des restrictions
et le pointeur sur la structure de r√©sultat. Il n‚Äôy a pas de callback pour
l‚Äôutilisateur car le r√©sultat est limit√© √† un seul fichier (en r√©alit√© il y a un
callback interne qui r√©cup√®re toutes les metadata car le vrai r√©sultat est sur
plusieurs lignes).

Les metadata sont disponibles dans une structure cha√Æn√©e. Je dois √©galement
introduire une nouvelle possibilit√© des restrictions. Mais tout d‚Äôabord, voici
un exemple :

```c
valhalla_db_filemeta_t *metadata = NULL;
valhalla_db_restrict_t r1 = VALHALLA_DB_RESTRICT_STR (EQUAL, "track", NULL);
valhalla_db_restrict_t r2 = VALHALLA_DB_RESTRICT_STR (EQUAL, "title", NULL);
VALHALLA_DB_RESTRICT_LINK (r2, r1);
valhalla_db_file_get (handle, 0, "/home/foo/bar/dido/life_for_rent/white_flag.m4a", &r1, &metadata);
/* ... */
VALHALLA_DB_FILEMETA_FREE (metadata);
```

L‚Äôargument `EQUAL` dans la macro `VALHALLA_DB_RESTRICT` sert √† limiter les
r√©sultats √† des metadata pr√©cises. Sans les restrictions, la structure metadata
contiendrait absolument toutes les metadata. Mais dans cet exemple, la structure
contient uniquement le track et le titre. A noter qu‚Äôutiliser IN ou NOTIN ici √ßa
n‚Äôa aucun sens. De m√™me qu‚Äôutiliser `EQUAL` pour les deux fonctions pr√©c√©dentes
(voir la conclusion).

> Il faut √™tre conscient que plusieurs tracks et plusieurs titres peuvent √™tre
> retourn√©s pour un m√™me fichier. Car rien n‚Äôexclus que certains noms de
> metadata n‚Äôexistent pas dans diff√©rents groupes. Et comme je l‚Äôai dis plus
> haut, il n‚Äôest pour le moment pas possible de limiter une restriction √† un
> groupe. N√©anmoins le groupe est un champ de la structure
> `valhalla_db_filemeta_t`, il est donc possible de faire un tri √† posteriori.

Apr√®s utilisation des metadata, il ne faut pas oublier de les lib√©rer avec
`VALHALLA_DB_FILEMETA_FREE()`.

### Et d‚Äôun point de vue SQL

```sql
SELECT file.file_id, assoc._grp_id, meta.meta_id, data.data_id, meta.meta_name, data.data_value
FROM ((
    file INNER JOIN assoc_file_metadata AS assoc
    ON file.file_id = assoc.file_id
  ) INNER JOIN data
  ON data.data_id = assoc.data_id
) INNER JOIN meta
ON assoc.meta_id = meta.meta_id
-- Les conditions sont optionnelles
WHERE
  -- Une condition appara√Æt par le biais des restrictions.
  -- Il y a autant de conditions que de restrictions du type EQUAL.
  -- A choix, il peut y avoir un ID ou du texte. Chaque restriction
  -- est s√©par√©e par un OR.
  (
    (meta.<meta_id|meta_name> = <ID|"TEXT"> AND data.<data_id|data_value> = <ID|"TEXT">)
    <OR> ...
  )
  -- Il faut l'id d'un fichier ou un path
  AND file.<file_id|file_path> = <ID|"PATH">
;
```

Cette requ√™te retourne autant de lignes qu‚Äôil y a de metadata. Mais pour
l‚Äôutilisateur, tout est transparent car les r√©sultats sont tous retourn√©s dans
une structure cha√Æn√©e.

## En conclusion

Les possibilit√©s de ce nouveau syst√®me sont tr√®s larges par rapport √† l‚Äôancien.
Bien qu‚Äôil y ait encore quelques manques pour pouvoir sp√©cifier des groupes avec
les restrictions, il est possible de retrouver les donn√©es avec peu de lignes de
code et simplement, tout en ayant des requ√™tes relativement complexes qui se
cr√©er en interne. Il y aura forc√©ment des modifications √† l‚Äôavenir, je t√¢cherais
de garder √† jour cet article.

Et pour en revenir aux restrictions et √† l‚Äôargument qui peut prendre la valeur
`IN`, `NOTIN` ou `EQUAL`, il faut comprendre que c‚Äôest avant tout une question
de factorisation en interne. `IN` et `NOTIN` devraient √™tre utilis√©s uniquement
avec les deux premi√®res fonctions pr√©sent√©es qui r√©cup√®rent des listes, et
`EQUAL` devrait √™tre utilis√© uniquement pour la r√©cup√©ration des metadata d‚Äôun
fichier. Je vais continuer √† travailler sur ces √©l√©ments dans les jours √† venir
afin d‚Äô√©viter des confusions.

A bient√¥t,  
Mathieu SCHROETER

[1]:
