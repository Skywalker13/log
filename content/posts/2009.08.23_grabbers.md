---
title: 'Avancement pour les "grabbers" ~ üá´üá∑'
date: 2009-08-23
tags: [geexbox, libvalhalla, enna]
description: "Grab"
draft: false
---

Hello,

plusieurs grabbers ont int√©gr√©s Valhalla depuis le dernier article, merci √†
Benjamin pour son travail. Il reste cependant quelques lacunes √† combler.
Certaines des fonctionnalit√©s manquantes sont mineurs et je ne vais donc pas les
aborder ici. M√™me que je ne compte pas travailler dessus tant que les plus
importantes ne seront pas impl√©ment√©es.

![](/img/heidrun.png)

## Scan "on-demand"

C'est s√ªrement une des fonctionnalit√©s la plus importante √† faire avant
l'int√©gration dans Enna. Son r√¥le est de permettre la r√©cup√©ration des
m√©ta-donn√©es en priorit√© (sur demande). L'id√©e est tr√®s simple, lorsque vous
utilisez Enna et ciblez un fichier en particulier, le r√¥le du "on-demand" sera
de fournir toutes les donn√©es le plus rapidement possible pour ce fichier. A
moins que ces donn√©es soient d√©j√† r√©cup√©r√©es et sauv√©es dans la base de donn√©es
(ainsi que les fichiers t√©l√©charg√©s tel que les couvertures).

Bien que l'id√©e soit simple, l'impl√©mentation est bien plus complexe. Valhalla
√©tant un scanner de r√©pertoire, il n'y a actuellement aucun m√©canisme pour
donner une priorit√© plus importante √† un fichier plut√¥t qu'un autre. Comme je
l'explique dans l'article pr√©c√©dent, les t√¢ches des threads de Valhalla
fonctionnent selon le principe du premier arriv√©, premier servi. Il faut donc
impl√©menter un moyen de mettre "un paquet" selon un LIFO (Last In, First Out) √†
la place d'un FIFO. Par exemple un attribut indiquerait que le paquet est
prioritaire et les queues seraient utilis√©es en LIFO. Les queues dans Valhalla
sont h√©rit√©es de libplayer. Elles se nomment `fifo_queue` et n'ont pas du tout
√©t√© pr√©vues pour le LIFO comme le sugg√®re leur nom. Il est peut √™tre temps de
les rendre plus polyvalentes. Je n'ai encore rien entrepris en ce sens, je ne
fais que des r√©flexions sur une mani√®re parmi d'autres de g√©rer le "on-demand".

Donner plus de priorit√© dans les queues ce n'est pas l'unique chose √† prendre en
compte. Le "on-demand" doit aussi pouvoir se faire sur des fichiers qui ne sont
pas disponibles avec les chemins scann√©s par Valhalla. Ce qui induit que ces
entr√©es doivent avoir un statu particulier dans la base de donn√©e, afin que
Valhalla ne les supprime pas lors du prochain scan, croyant que se sont des
fichiers effac√©s car introuvables. Quoi qu'il en soit, avant d'√©crire la moindre
ligne de code, il est important de faire toutes les consid√©rations n√©cessaires
afin de ne pas introduire des modifications trop intrusives aussi bien au niveau
interne de Valhalla qu'au niveau de la structure de la base de donn√©e.

## Le "force-stop"

Depuis la premi√®re version de Valhalla, il est possible d'arr√™ter un scanner (et
donc tous les threads en aval) m√™me si le syst√®me est en train de travailler sur
des fichiers √† diff√©rents niveaux. Le fait d'avoir ajout√© les grabbers √†
fortement compliqu√© cette fonctionnalit√© de "force-stop" qui n'est actuellement
pas optimale. J'ai du faire un choix afin de pouvoir commiter le code sur les
grabbers m√™me si je n'ai pas termin√© cette part du travail.

Mais tout d'abord, pourquoi le "force-stop"? Lorsque vous √™tes dans Enna,
Valhalla tourne en arri√®re plan avec une priorit√© tr√®s basse afin de ne pas
influencer l'interface et les lectures des fichiers. Si vous quittez Enna, vous
voulez le faire imm√©diatement ce qui semble logique. Par contre pour Valhalla
c'est plus compliqu√©. L'arr√™ter en plein au milieu de t√¢ches l'oblige √† ne pas
pouvoir vider les queues des threads. Toutes les donn√©es dans ces queues sont
donc lib√©r√©es et perdues. Avant l'ajout des grabbers ce n'√©tait pas du tout un
probl√®me, car le syst√®me se limitait √† une seule √©tape; le parser. Un thread
n'est pas tu√© avec le "force-stop", mais sa derni√®re t√¢che est termin√©e
normalement. La diff√©rence est que les t√¢ches suivantes sont ignor√©es et le
thread se termine comme s'il n'y avait rien de plus √† faire. Ainsi avant l'ajout
des grabbers, au pire les fichiers restant dans les queues n'√©taient pas
ins√©r√©s/actualis√©s dans la base de donn√©e. Les fichiers qui √©taient d√©j√† ins√©r√©s
l'√©taient au complet. Ceux qui ne l'√©taient pas, ne l'√©taient pas du tout.
C'√©tait du tout ou rien. Le prochain scan (d√©marrage d'Enna) permettait de
continuer le travail tr√®s simplement. Les queues se repeuplaient par le scanner
qui ne trouvait pas les fichiers dans la base de donn√©es, et ignorait ceux qui
existaient d√©j√† (c'est toujours le cas "plus-ou-moins" si vous compilez Valhalla
sans les grabbers).

Depuis que les grabbers sont pr√©sents, la complexit√© du "force-stop" a augment√©
pour deux raisons. Un fichier peut exister dans plusieurs queues en m√™me temps,
et un fichier doit passer par plusieurs √©tapes avant d'√™tre termin√©. Les donn√©es
d'un fichier dans la base de donn√©e ne peuvent plus √™tre consid√©r√©es comme du
tout ou rien. Un fichier se retrouve compl√®tement fragment√© quand les threads
sont tous termin√©s en plein au milieu des t√¢ches.

### Fonctionnement actuel

J'ai donc fais un choix interm√©diaire pour que Valhalla fonctionne aussi en
"force-stop" bien que le probl√®me de fragmentation ne soit pas r√©gl√©. J'ai
d√©cid√© de traiter un fichier comme c'est le cas sans le support des grabbers
mais √† une diff√©rence pr√®s. Un fichier est consid√©r√© comme interrompu tant qu'il
n'a pas atteint l'√©tape `ENDING` (voir l'article [pr√©c√©dent][1]). Donc au
prochain scan (red√©marrage de Valhalla), ce fichier repassera absolument par
toutes les √©tapes. Le probl√®me est donc que les donn√©es d√©j√† grabb√©es (et
sauv√©es dans la DB) sont re-grabb√©es ce qui prend beaucoup de temps inutile.
Avec des milliers de fichiers et beaucoup de grabbers, il se trouve que Valhalla
passe son temps √† refaire encore et encore le m√™me travail si on ne le laisse
pas se terminer de lui m√™me. Car pour qu'un fichier puisse atteindre l'√©tape
`ENDING` quand il y a 5-6 grabbers, il faut se lever t√¥t ;-). Ce syst√®me est
provisoire! Il est l√† en attendant que j'y travail. Et c'est une des raisons qui
fait que Valhalla ne doit pas encore √™tre utilis√© avec les grabbers dans Enna.

Pourquoi de la fragmentation? Alors √ßa n'a rien √† voir avec votre disque dur,
quand je parle de fragmentation c'est dans le sens o√π toutes les informations
qui devraient l'√™tre ne sont pas disponibles dans la base de donn√©e. Par exemple
un fichier est pass√© par l'√©tape `PARSING` et `GRABBING` (le premier grabber).
Les m√©ta-donn√©es du parser ont √©t√© sauv√©es dans la DB, ainsi que celle du
premier grabber par exemple. N√©anmoins il y a peut √™tre encore 4 grabbers avant
le downloader et l'`ENDING`. Le "force-stop" arr√™te tout, vide les queues,
quitte Valhalla. Il se trouve que le fichier en question a une partie des
m√©ta-donn√©es dans la base de donn√©e, mais on a aucune certitude qu'elle soient
toutes disponibles car ce fichier est indiqu√© comme √©tant interrompu.

### Fonctionnement futur

Je suis en train de r√©fl√©chir √† ce probl√®me (sur papier pour le moment). Ce
qu'il faut arriver √† faire, c'est de sauver le contexte des fichiers interrompus
pour pouvoir restaurer leur contexte √† la prochaine ex√©cution de Valhalla. Il
n'y a donc pas 50 mani√®res de faire. La sauvegarde du contexte doit √™tre
r√©alis√©e dans la base de donn√©e. Un m√©canisme √† l'ex√©cution de Valhalla devra
chercher les contextes, les restaurer puis les effacer de la base de donn√©es.

Un contexte devra contenir les informations sur quels grabbers ont √©t√© trait√©s
en entier (ceux o√π les donn√©es sont vraiment sauv√©es) ainsi que la liste des
fichiers qui doivent √™tre t√©l√©charg√©s. Il faut aussi consid√©rer les cas o√π des
contextes ont √©t√© sauv√©s mais que certains grabbers ne sont plus disponibles
avec Valhalla, ou m√™me qu'un Valhalla sans le support des grabbers essaient
d'utiliser la base de donn√©es qui contient ces contextes.

Concernant le downloader c'est un peu diff√©rent par rapport aux autres threads.
Comme je l'ai dis pr√©c√©demment, un thread termine sa t√¢che en cours puis quitte.
Pour le downloader une t√¢che peut √™tre interrompue en plein au mieux. Cela veut
simplement dire que pour un fichier en particulier, il y a par exemple un
"cover", un "backdrop" et peut √™tre encore autre chose √† t√©l√©charger. Il se peut
que le "cover" soit t√©l√©charg√©, que le "force-stop" se manifeste et donc le
"backdrop" est ignor√©. La t√¢che est √† moiti√© r√©alis√©e. Il est donc n√©cessaire de
sauvegarder l'√©tat de cette t√¢che avant de quitter le thread du downloader.

Finalement √ßa repr√©sente des ajouts de tables dans la base de donn√©es pour
sauvegarder les contextes, des m√©canismes pour g√©rer les contextes (sauvegarde,
restauration et effacement), puis ensuite on pourra r√©fl√©chir s√©rieusement √†
l'int√©gration dans Enna.

## Les √©v√®nements

Le dernier point relativement important est la gestion des √©v√®nements pour un
scan "on-demand". Les donn√©es √©tant ins√©r√©es au fur et √† mesure dans la base de
donn√©e, il est int√©ressant de recevoir une information sur ce qui est disponible
afin de savoir quand aller les lire. Simplement, lorsque vous √™tes sur un
fichier en particulier avec Enna, un "backdrop" va se t√©l√©charger √† un moment
ind√©termin√©. Un √©v√®nement sera envoy√© par Valhalla √† Enna quand le fichier sera
sauv√© et le "backdrop" s'affichera.

C'est avant tout une question de confort que d'avoir cette fonctionnalit√©. Dans
le cas contraire il serait n√©cessaire d'aller lire les donn√©es que lors de
l'acc√®s au fichier, et les images par exemple ne s'afficheraient qu'en changeant
de fichier, puis en revenant sur le pr√©c√©dent (pour autant que quelque chose
s'est t√©l√©charg√© entre temps).

‚Ä¶

Il y a d'autres points mais moins prioritaires. Je compte travailler
sp√©cialement sur les trois probl√®mes pr√©sent√©s dans cet article. J'ai d√©j√† fais
un peu de travail sur le "force-stop". Apr√®s je pense r√©gler le "on-demand" puis
les √©v√®nements.

A bient√¥t,  
Mathieu SCHROETER

[1]: /posts/2009.08.11_grabbers/
