---
title: "La liste de lecture de libplayer ~ ğŸ‡«ğŸ‡·"
date: 2009-08-02
tags: [geexbox, libplayer]
description: "Liste de lecture"
draft: true
---

Hello,

cet Ã©tÃ© jâ€™ai bossÃ© un peu sur libvalhalla pour ajouter le support des grabbers.
Le travail nâ€™est pas terminÃ© et rien nâ€™a encore Ã©tÃ© commitÃ© car les
modifications sont trÃ¨s intrusives et forment un tout. Je nâ€™ai encore rien Ã 
prÃ©senter de concret mais jâ€™espÃ¨re en terminer avec Ã§a les deux premiÃ¨res
semaines dâ€™aoÃ»t. Soit mes deux derniÃ¨re semaines de congÃ©.

## La liste de lecture

<img src="/img/libplayer.png" width="400px"/>

Mais ce nâ€™est pas de Valhalla que je dÃ©sire parler. Mais plutÃ´t de libplayer et
de quelques fonctionnalitÃ©s qui existent depuis bien longtemps et qui ne sont
pas forcÃ©ment connues et qui ne seront mÃªme jamais utilisÃ©es par Enna. Avant
lâ€™entrÃ©e en jeu dâ€™Enna dans le monde de GeeXboX il y a eu quelques tentatives de
nouveaux GUI tel que MPUI, OMCv1, OMC-SDL puis OMCv2. Aucun de ces projets nâ€™a
abouti mais libplayer a Ã©tÃ© crÃ©Ã© en parallÃ¨le Ã  OMCv1 (je prÃ©cise v1 et v2 car
il y a eu deux tentatives diffÃ©rentes de crÃ©er un GUI basÃ© sur les EFL). Pendant
une pÃ©riode, il avait Ã©tÃ© proposÃ© de laisser la gestion des listes de lecture Ã 
libplayer. Au dÃ©but cette gestion Ã©tait trÃ¨s rudimentaire et ne permettait que
dâ€™ajouter des fichiers dans la liste. Jâ€™ai donc pris lâ€™initiative dâ€™Ã©tendre la
gestion de ces listes, et spÃ©cialement avec lâ€™ajout du superviseur (cf.
[libplayer-et-le-multi-threading][1]) qui date dâ€™une annÃ©e.

Libplayer contient une playlist interne. Elle nâ€™est pas accessible depuis lâ€™API
publique et uniquement une playlist peut exister dans un player Ã  la fois. Cette
liste se prÃ©sente en une structure chaÃ®nÃ©e dans laquelle il est possible de
progresser en avant ou en arriÃ¨re. Cela implique que lâ€™ordre dâ€™insertion des
fichiers dÃ©fini lâ€™ordre de lecture. Ainsi il existe deux maniÃ¨res de lire la
liste. Pour cela il mâ€™est nÃ©cessaire de prÃ©senter quelques fonctions de lâ€™API
publique, ainsi quâ€™une fonction interne un peu diffÃ©rente.

Chaque entrÃ©e dans la playlist est un morceau de la structure chaÃ®nÃ©e, visible
en tant que type opaque nommÃ© `mrl_t`. Il y a quelques fonctions de base pour
travailler avec ces type, tel que `mrl_new()`, `mrl_free()` et diffÃ©rents
accesseurs. Mais il y a Ã©galement des fonctions pour assigner un `mrl_t` Ã  la
playlist. Tel que `player_mrl_set()` et `player_mrl_append()` qui permettent
dâ€™insÃ©rer un mrl Ã  lâ€™emplacement courant, respectivement Ã  la suite du mrl
courant. Ainsi une sÃ©rie de `player_mrl_append()` vont permettre de remplir la
liste de lecture. Lâ€™ordre dâ€™insertion Ã©tant directement liÃ© Ã  lâ€™ordre de
lecture. Il existe Ã©galement des fonctions pour supprimer des mrls tel que
`player_mrl_remove()` et `player_mrl_remove_all()`. Tout ceci nâ€™est quâ€™une
prÃ©sentation rapide de quelques fonctions de base. Certaines dâ€™entre elles sont
utilisÃ©es par Enna car il faut bien au moins assigner un `mrl_t` Ã  libplayer
pour quâ€™un fichier (url, dvd, â€¦) puisse Ãªtre lu. Mais il existe dâ€™autres
fonctionnalitÃ©s pour effectuer des lectures automatisÃ©es de la liste de lecture.
Ces fonctions nâ€™ont aucun intÃ©rÃªt pour Enna qui gÃ¨re dÃ©jÃ  ses propres listes de
lecture.

### Les fonctions de playback

Il y a trois fonctions de playback intÃ©ressantes pour la liste de lecture de
libplayer.

- `player_set_playback()`  
  Deux modes peuvent Ãªtre dÃ©fini, soit `PLAYER_PB_SINGLE` ou `PLAYER_PB_AUTO`.
  Dans le cas de â€œsingleâ€, seul le mrl en cours sera lu lors dâ€™un appel Ã 
  `player_playback_start()`. Le mode â€œautoâ€ va permettre Ã  libplayer de lire
  toute la liste de lecture sans une intervention de lâ€™extÃ©rieur. A chaque
  morceau qui se termine, libplayer va passer au suivant jusquâ€™Ã  atteindre la
  fin de la liste.

Le fait de lire la liste depuis la position courante jusquâ€™Ã  la fin nâ€™est pas
toujours trÃ¨s intÃ©ressant, il existe donc deux fonctions qui sont trÃ¨s souvent
prÃ©sentes dans ce type de logiciel.

- `player_set_loop()`  
  Pour autant que le mode est en â€œautoâ€, il est possible de dire Ã  libplayer de
  rÃ©pÃ©ter le mÃªme morceau un certain nombre de fois avec `PLAYER_LOOP_ELEMENT`,
  ou alors de rÃ©pÃ©ter la liste de lecture avec `PLAYER_LOOP_PLAYLIST`. Un
  paramÃ¨tre de cette fonction permet de dire combien de fois et si ce paramÃ¨tre
  est nÃ©gatif, le bouclage est infini.

- `player_set_shuffle()`  
  Ici aussi, le mode de playback doit Ãªtre â€œautoâ€. Ainsi la liste de lecture
  sera mÃ©langÃ©e et le morceau lu suivant sera diffÃ©rent de lâ€™ordre dâ€™insertion
  des morceaux dans la liste de lecture. Chaque activation et dÃ©sactivation du
  â€œshuffleâ€ va rÃ©initialiser la liste de lecture et donc mÃ©langer lâ€™ordre.

Bien sÃ»r il est possible de combiner les fonctionnalitÃ©s. Si le â€œloopâ€ est
indiquÃ© sur `PLAYER_LOOP_PLAYLIST` et que le â€œshuffleâ€ est activÃ©, chaque fois
que libplayer arrive Ã  la fin de la liste de lecture, il la mÃ©langera Ã  nouveau
et recommencera autant de fois quâ€™il a Ã©tÃ© spÃ©cifiÃ© avec `player_set_loop()`.
Vous vous dites quâ€™il nâ€™y a rien dâ€™exceptionnel la dedans, vous avez tout Ã  fait
raison. Mon but est uniquement de prÃ©senter quelques fonctionnalitÃ©s
exploitables partiellement que par un seul outil â€œtest-playerâ€ et forcÃ©ment
ignorÃ©es dâ€™Enna. Lorsque test-player est lancÃ©, il suffit dâ€™utiliser [#] pour
changer de mode, [.] pour changer le bouclage (il y a quelques valeurs
prÃ©dÃ©finies) et [,] pour mÃ©langer la liste.

## Lâ€™automatisation de la lecture

Jâ€™ai parlÃ© au dÃ©but dâ€™une fonction un peu diffÃ©rente. Cette fonction permet de
rendre possible la lecture bouclÃ©e et mÃ©langÃ©e. Mais avant Ã§a un petit peu de
thÃ©orie sur libplayer. Bien quâ€™il nâ€™y a Ã  priori rien dâ€™exceptionnel
dâ€™automatiser la lecture dans libplayer, il faut quâ€™en mÃªme se poser une
question. Le fait dâ€™automatiser la lecture prÃ©sage lâ€™existence dâ€™une boucle.
Ainsi lorsquâ€™un fichier est lu en entier (donc un Ã©vÃ©nement du type `EOF` est
gÃ©nÃ©rÃ©) il faut forcer le passage au morceau suivant dâ€™une maniÃ¨re ou dâ€™une
autre.

Imaginons que le playback a Ã©tÃ© dÃ©fini en â€œautoâ€ et que la lecture a Ã©tÃ© amorcÃ©e
via `player_playback_start()`. Cette fonction de start ne doit en aucun cas Ãªtre
bloquÃ©e jusquâ€™Ã  la fin de la lecture. La chaÃ®ne dâ€™exÃ©cution peut se visualiser
ainsi:

dÃ©marrage de la lecture â†’ sÃ©lection du morceau â†’ lecture â†’ Ã©vÃ©nement de fin de
lecture â†’ sÃ©lection du morceau suivant â†’ lecture â†’ etc, â€¦

Il y a une rÃ©troaction et Ã§a complique grandement les choses. Le premier
dÃ©marrage de la lecture est amorcÃ© Ã  lâ€™extÃ©rieur via lâ€™utilisateur et cette
fonction nâ€™est pas bloquÃ©e jusquâ€™Ã  `lâ€™EOF` (en rÃ©alitÃ© elle bloque jusquâ€™Ã  ce
que la lecture soit rÃ©ellement lancÃ©e). Donc le programme qui utilise libplayer
peut faire autre chose en mÃªme tant que le mÃ©dia se lit. Il est donc nÃ©cessaire
dâ€™intercepter la fin de la lecture Ã  lâ€™intÃ©rieur de libplayer pour que se sois
la bibliothÃ¨que qui passe au morceau suivant. Le problÃ¨me nâ€™est peut Ãªtre pas
tout de suite Ã©vident, alors dÃ©taillons la chaÃ®ne.

Lorsque la lecture se termine un Ã©vÃ©nement est crÃ©Ã©, il est ensuite envoyÃ© dans
un callback interne (pour que libplayer sache que la lecture est terminÃ©e) et se
callback envoi lâ€™Ã©vÃ©nement Ã  un callback externe (pour que lâ€™utilisateur de la
lib soit aussi informÃ©). Si depuis ce callback interne, un nouveau
`player_playback_start()` serait amorcÃ©, le callback serait bloquÃ© tant que la
lecture nâ€™a pas rÃ©ellement commencÃ©. Et dÃ¨s que celle-ci dÃ©marre vraiment, la
fonction est relÃ¢chÃ©e. De ce fait, le callback interne resterait bloquÃ© par le
`player_playback_start()` pendant tout ce temps (si câ€™est un flux rÃ©seau, Ã§a
peut prendre quelques secondes). Les Ã©vÃ©nements qui arriveraient entre le EOF et
la fin du nouveau start sâ€™empileraient et ne seraient pas envoyÃ©s. Ainsi des
Ã©vÃ©nements pÃ©rimÃ©s arriveraient Ã  lâ€™utilisateur aprÃ¨s le start et ce nâ€™est pas
acceptable.

> En rÃ©alitÃ© câ€™est encore un peu plus compliquÃ© que Ã§a, mais il est inutile
> dâ€™aller dans les dÃ©tails.

Le superviseur et le gestionnaire dâ€™Ã©vÃ©nement de libplayer permettent donc de
gÃ©rer se problÃ¨me. Lorsquâ€™un Ã©vÃ©nement est envoyÃ©, il est empilÃ© dans un FIFO.
Les Ã©vÃ©nements sont prioritaires et le superviseur est dÃ©sactivÃ© lorsque lâ€™un
dâ€™eux survient. Ainsi il ne peut jamais y avoir dâ€™Ã©vÃ©nements pÃ©rimÃ©s. La
deuxiÃ¨me chose concerne le superviseur en lui mÃªme. Il met Ã  disposition deux
moyens pour exÃ©cuter une commande tel que le `player_playback_start()` par
exemple. Le premier est le mode `WAIT`, et le second `NO_WAIT`. La diffÃ©rence
est que le premier est utilisÃ© pour toutes les fonctions publiques. Cela veut
dire que tant que la fonction nâ€™est pas terminÃ©e (par exemple tant que le start
nâ€™a pas rÃ©ellement commencÃ©), lâ€™utilisateur est bloquÃ©. Le second mode permet de
lancer une fonction mais sans aucune attente. Par exemple le start serait empilÃ©
dans le FIFO du superviseur mais nâ€™attendrait pas. Ce mode nâ€™est pas autorisÃ©
depuis lâ€™API publique pour plusieurs raisons, dont une trÃ¨s importante. Lorsque
lâ€™utilisateur utilise la bibliothÃ¨que il doit Ãªtre sÃ»r que la commande soit
effectivement exÃ©cutÃ©e afin dâ€™avoir un comportement â€œnormalâ€ donc comme sâ€™il nâ€™y
avait pas de parallÃ©lisme. Quand vous faites par exemple un `printf()`, vous
voulez que celui-ci sâ€™exÃ©cute Ã  ce moment lÃ  et pas 2 secondes plus tard. Sinon
dans le cas de libplayer, vous feriez un start, puis autre chose, un stop,
get_property, etc,.. Sans savoir quand est-ce que les fonctions seront
rÃ©ellement exÃ©cutÃ©es. Dit autrement, les fonctions de lâ€™API publique sont toutes
**synchrones**. Lâ€™autre mode est asynchrone et demande quelques considÃ©rations.
Pour les fonctions qui retournent des valeurs par exemple, si lâ€™API publique
Ã©tait asynchrone, il faudrait pouvoir indiquer un callback pour chaque fonction
afin dâ€™avoir un moyen de rÃ©cupÃ©rer les valeurs. Cette fonctionnalitÃ© nâ€™est pas
disponible actuellement.

Mais revenons en Ã  lâ€™automatisation de la lecture. Pour que libplayer puisse
passer au morceau suivant sans bloquer le callback du gestionnaire dâ€™Ã©vÃ©nement
il doit travailler de maniÃ¨re **asynchrone**. Câ€™est donc (Ã  lâ€™heure oÃ¹ jâ€™Ã©cris
ces lignes) le seul endroit oÃ¹ une fonction est utilisÃ©e en `NO_WAIT` (en vÃ©ritÃ©
ce nâ€™est pas tout Ã  fait vrai, mais je vous Ã©pargne les autres cas
particuliers). Cette fonction se nomme:

- `player_mrl_next_play()`  
  Les fonctions `player_mrl_next()` et `player_mrl_previous()` Ã  disposition
  dans lâ€™API publique permettent de progresser dans la liste de lecture par
  rapport Ã  lâ€™ordre dâ€™insertion des mrls. La fonction next_play est bien
  diffÃ©rente. Elle va tenir compte du â€œloopâ€ et du â€œshuffleâ€ et est donc un peu
  plus sophistiquÃ©e.

Je nâ€™ai pas rendu accessible cette fonction depuis lâ€™API publique pour aucune
bonne raison. Elle peut trÃ¨s bien Ãªtre utilisÃ©e de maniÃ¨re synchrone. Elle est
utilisÃ©e en asynchrone dans libplayer pour libÃ©rer le callback le plus vite
possible et donc pour respecter la bonne marche des Ã©vÃ©nements. Le fait que les
Ã©vÃ©nements sont prioritaires au superviseur indique aussi que la fonction ne
pourra jamais se terminer tant que le gestionnaire dâ€™Ã©vÃ©nement ne redonne pas la
main au superviseur. Une fonction forcÃ©e en `WAIT` provoquerait irrÃ©mÃ©diablement
un deadlock. Autrement dit ce serait le serpent qui se mort la queue (ou qui se
mort le FIFO).

## Conclusion

Le but de cet article est de montrer une facette peu connue de libplayer. Et que
cette bibliothÃ¨que est bien plus quâ€™une simple couche dâ€™abstraction sur MPlayer,
xine, VLC et GStreamer. Les rÃ´les du superviseur et du gestionnaire dâ€™Ã©vÃ©nement
ne se limitent pas quâ€™aux cas dâ€™utilisations exprimÃ©s prÃ©cÃ©demment. Il y a de
nombreuses autres raisons mais ce nâ€™est pas lâ€™objectif de cet article que dâ€™en
parler en dÃ©tail ici.

A bientÃ´t,  
Mathieu SCHROETER
